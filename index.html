<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="gbetter">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="gbetter">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gbetter">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> gbetter </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">gbetter</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/08/HTML学习笔记二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/08/HTML学习笔记二/" itemprop="url">
                  HTML学习笔记二
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-08T00:36:55+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h3><h4 id="表格的应用"><a href="#表格的应用" class="headerlink" title="表格的应用"></a>表格的应用</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/05/HTML学习笔记一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/05/HTML学习笔记一/" itemprop="url">
                  HTML学习笔记一
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-05T10:03:59+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h3><h4 id="HTML-的基本结构"><a href="#HTML-的基本结构" class="headerlink" title="HTML 的基本结构"></a>HTML 的基本结构</h4><ol>
<li>一个 HTML 文件是由一系列的元素和标签组成的，HITML 的标签分为单独标签和成对标签两种。在每个 HTML 标签中不区分大小写。</li>
<li>当用一组 HTML 标签将一段文字包含在中间时，这段文字与包含文字的 HTML 标签被称为一个元素。</li>
<li>文件的开始标签 <code>&lt;html&gt; 文件的全部内容 &lt;/html&gt;</code></li>
<li>文件的头部标签 <code>&lt;head&gt; &lt;/head&gt;</code> 主要包含文件的标题、编码方式、URL等信息，如果不提供，可省略。</li>
<li>文件主题标签 <code>&lt;body&gt;&lt;/body&gt;</code> 包含该网页的主体内容。</li>
</ol>
<h4 id="HTML-文件基本标记"><a href="#HTML-文件基本标记" class="headerlink" title="HTML 文件基本标记"></a>HTML 文件基本标记</h4><ol>
<li>标题标记 <code>&lt;title&gt;...&lt;/title&gt;</code> 标记的内部就是标题的内容。</li>
<li><p>元信息标记 <code>&lt;meta ...&gt;</code> 提供的信息，不显示在页面中，一般用于定义页面信息的名称、关键字、作者等， meta 元素的属性有两种：<code>name</code> 和 <code>http-equiv</code>：</p>
<ol>
<li>设置页面关键字，便于帮助搜索引擎对该网页进行查找和分类：<code>&lt;meta name=&quot;keyname&quot; content=&quot;关键字1,关键字2&quot;&gt;</code></li>
<li>设置页面描述：<code>&lt;meta name=&quot;description&quot; content=&quot;对页面的描述语言&quot;&gt;</code></li>
<li>设置编辑工具: <code>&lt;meta name=&quot;generator&quot; content=&quot;sublime&quot;&gt;</code></li>
<li>设定作者信息：<code>&lt;meta name=&quot;author&quot; content=&quot;zhangsan&quot;&gt;</code></li>
<li>限定搜索方式：<code>&lt;meta name=&quot;robots&quot; content=&quot;All/Index/Nofollow/Noindex/None&quot;&gt;</code> (All: 表示能搜索当前网页及其链接的网页；Index：表示能搜索当前网页；Nofollow：表示不能搜索当前网页链接的网页；Noindex：表示不能搜索当前页；None：表示都不能搜索)。</li>
<li>设置网页文字及语言：<br><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot; charset=&quot;utf-8&quot;&gt;</code> <br> <code>&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;en&quot;&gt;</code>。</li>
<li>设置网页的定时跳转：<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;跳转时间;url=链接地址&quot;&gt;</code> （跳转时间是以秒为单位）。</li>
<li>设置有效期限：<code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed,14 september 2017 23:14:00 GMT&quot;&gt;</code> 到期的时间必须是 GMT 格式时间。</li>
<li>禁止从缓存中调用：<br><code>&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</code> <br> <code>&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;</code></li>
<li>删除过期的 cookie：<br> <code>&lt;meta http-equiv=&quot;set-cookie&quot; content=&quot;Wed,14 september 2017 23:20:00 GMT&quot;&gt;</code></li>
<li>强制打开新的窗口：（可以防止自己的网页被当做一个frame页调用）<br> <code>&lt;meta http-equiv=&quot;windows-target&quot; content=&quot;_top&quot;&gt;</code> <br> 在该语法中，windows-target 表示新网页的打开方式，而<code>_top</code>表示打开的是一个独立页面。</li>
<li>设置网页的过度效果：<br> <code>&lt;meta http-equiv=&quot;page-exist/page-enter(过渡事件)&quot; content=&quot;revealtrans(duration=3（时间）,transition=21（方式）)&quot;&gt;</code></li>
</ol>
</li>
<li><p>基底网址标志<code>&lt;base&gt;</code> ：<br> <code>&lt;base href=&quot;链接地址&quot; target=&quot;新窗口的打开方式&quot;&gt;</code>      </p>
<ul>
<li><code>_parent</code>:在上一级窗口中打开，一般常用在分针的框架页中</li>
<li><code>_blank</code>: 在新窗口中打开</li>
<li><code>_self</code>: 在同一窗口打开，可省略</li>
<li><code>_top</code>: 在浏览器的真嘎窗口打开，忽略任何框架</li>
</ul>
</li>
<li>页面的主体标记<code>&lt;body&gt;</code>:<ul>
<li><code>text</code>: 设定页面的文字颜色</li>
<li><code>bgcolor</code>：设定页面的背景颜色</li>
<li><code>backgroud</code>：设定页面的背景图片</li>
<li><code>bgproperties</code>:设定页面的背景图片为固定，不随页面的滚动而滚动（<strong>值设置为 fixed 图片会固定在页面上</strong>）</li>
<li><code>link</code>：设定页面默认的链接颜色</li>
<li><code>alink</code>：设定鼠标正在单击时的链接颜色</li>
<li><code>vlink</code>：设定访问过后的链接颜色</li>
<li><code>topmargin</code>：设定页面的上边距</li>
<li><code>leftmargin</code>：设定页面的左边距     </li>
</ul>
</li>
<li>页面的注释标记： <code>&lt;!--注释的文字--&gt;</code></li>
</ol>
<h4 id="设计网页文本内容"><a href="#设计网页文本内容" class="headerlink" title="设计网页文本内容"></a>设计网页文本内容</h4><ol>
<li>标题文本标记：<code>&lt;h1~6&gt;...&lt;/h1~h6&gt;</code> 共包含六中标记<ul>
<li><code>align</code>    对齐方式：left、right、center</li>
</ul>
</li>
<li>设置文字格式：<br><code>&lt;foot face=&quot;字体1,字体2...&quot; size=&quot;4&quot; color=&quot;#FF0000&quot;&gt;...&lt;/foot&gt;</code><ul>
<li>face:字体，属性的值可以设置多个，默认使用第一种字体进行显示，以次类推。</li>
<li>size：字号，文字的字号可以设置为1~7，也可以是+1~+7或者-1~-7，默认的字体是3号。</li>
<li>color：颜色</li>
</ul>
</li>
<li>粗体、斜体、下划线 - strong、em、u（b、i、cite）<ul>
<li><code>&lt;strong&gt;粗体&lt;/strong&gt;</code>==<code>&lt;b&gt;粗体&lt;/b&gt;</code></li>
<li><code>&lt;em&gt;斜体&lt;/em&gt;</code>==<code>&lt;i&gt;斜体&lt;/i&gt;</code></li>
<li><code>&lt;u&gt;下划线&lt;/u&gt;</code>==<code>&lt;cite&gt;下划线&lt;/cite&gt;</code></li>
<li><code>&lt;sup&gt;上标&lt;/sup&gt; &lt;sub&gt;下标&lt;/sub&gt;</code></li>
<li><code>&lt;strike&gt;删除线&lt;/strike&gt;</code>==<code>&lt;del&gt;删除线&lt;/del&gt;</code></li>
<li><code>&lt;code&gt;等宽文字&lt;/code&gt;</code>==<code>&lt;samp&gt;等宽文字&lt;/samp&gt;</code></li>
<li><code>&amp;nbsp</code>：空格 <code>&amp;quot</code>：引号 <code>&amp;lt</code>:左尖括号 <code>&amp;gt</code>:右尖括号</li>
<li><code>&amp;times</code>：乘号 <code>&amp;copy</code>:版权所有符 <code>&amp;ret</code>:已注册的符号(。・・)</li>
</ul>
</li>
<li>设置段落格式： <code>&lt;p&gt;...&lt;/p&gt;</code>    <ul>
<li>取消文字换行：<code>&lt;nobr&gt;不换行的文字&lt;/nobr&gt;</code></li>
<li>换行标记：<code>&lt;br&gt;</code></li>
<li>保留原始排版方式标记：<code>&lt;pre&gt;...&lt;/pre&gt;</code></li>
<li>居中对齐标记:<code>&lt;center&gt;居中&lt;/center&gt;</code></li>
<li>向右缩进标记：<code>&lt;blockquote&gt;&lt;/blockquote&gt;</code></li>
</ul>
</li>
<li>水平线标记：<code>&lt;hr&gt;</code><ul>
<li>设置水平线的宽度和高度：<code>&lt;hr width=&quot;80%&quot; size=3&gt;</code> width可以是确定的像素值或窗口宽度值的百分比，高度只能够是像素值.</li>
<li>设置水平线的颜色: <code>&lt;hr colot=&quot;#FF0000&quot;&gt;</code></li>
<li>设置水平线的对齐方式:<code>&lt;hr align=&quot;center&quot;&gt;</code></li>
<li>去掉水平线的阴影:<code>&lt;hr noshade=&quot;noshade&quot;&gt;</code></li>
</ul>
</li>
<li>文字标注标记：<code>&lt;ruby&gt;被说明的文字&lt;rt&gt;文字的标志&lt;/rt&gt;&lt;/ruby&gt;</code><br> <ruby>被说明的文字<rt>文字的标志</rt></ruby></li>
<li>声明变量标记 var：<code>&lt;p&gt;&lt;var&gt;x&lt;/var&gt;=&lt;var&gt;y&lt;/var&gt;+6&lt;/p&gt;</code></li>
<li>忽视HTML标记：<code>&lt;plaintext&gt;</code> 或者 <code>&lt;xmp&gt;</code></li>
</ol>
<h4 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h4><ol>
<li><p>使用无序列表 ul：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;font size=&quot;+3&quot; color=&quot;#0066FF&quot;&gt;无序列表：&lt;/font&gt;</div><div class="line">&lt;ul type=&quot;circle&quot;&gt;</div><div class="line">	&lt;li type=&quot;square&quot;&gt;入门模式&lt;/li&gt;</div><div class="line">	&lt;li type=&quot;disc&quot;&gt;初级模式&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>使用有序列表 ol：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;font size=&quot;+3&quot; color=&quot;#FF0000&quot;&gt;有序列表标记:&lt;/font&gt;</div><div class="line">&lt;ol type=&quot;A&quot; start=&quot;5&quot;&gt;</div><div class="line">	&lt;li&gt;穿越时光术&lt;/li&gt;</div><div class="line">	&lt;li&gt;隐形透明术&lt;/li&gt;</div><div class="line">	&lt;li&gt;青春不老术&lt;/li&gt;</div><div class="line">&lt;/ol&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>type:类型（1、a、A、i、I）<br>start:起始数值（无论是数字、英文、罗马数字，起始数值只能是数字）</p>
</blockquote>
</li>
<li><p>定义列表标记 dl：（主要用于解释名词）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;font size=&quot;+3&quot; color=&quot;#00FFCC&quot;&gt;定义列表：&lt;/font&gt;</div><div class="line">&lt;dl&gt;</div><div class="line">	&lt;dt&gt;穿越时光术&lt;/dt&gt;&lt;dd&gt;你的时间在浪费发呆，胡思乱想，做白日梦；这类型的人个性很被动，想法天马行空，可只限于想而不实际行动。&lt;/dd&gt;&lt;br&gt;</div><div class="line">	&lt;dt&gt;隐形透明术&lt;/dt&gt;&lt;dd&gt;你的时间都浪费在看电视，上网瞎看一通：这种人内向不喜欢跟人实际的接触，凡事都跟人保持距离，不喜欢成为瞩目的焦点，宁愿躲在一边做自己的事情&lt;/dd&gt;</div><div class="line">&lt;/dl&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>菜单列表标记 menu：主要用于设计单列的菜单列表，效果与无需列表相同。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;font size=&quot;+3&quot; color=&quot;#3300FF&quot;&gt;菜单列表标记：&lt;/font&gt;</div><div class="line">&lt;menu&gt;</div><div class="line"> 	&lt;li type=&quot;square&quot;&gt;列表项1&lt;/li&gt;</div><div class="line"> 	&lt;li&gt;列表项2&lt;/li&gt;</div><div class="line"> 	&lt;li&gt;列表项3&lt;/li&gt;</div><div class="line"> 	&lt;li&gt;列表项4&lt;/li&gt;</div><div class="line">&lt;/menu&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>目录列表 dir：主要用于显示文件内容的目录大纲，通常用于设计一个压缩窄列的列表，如字典中的索引或单词表中的单词等。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;font size=&quot;+3&quot; color=&quot;#003300&quot;&gt;目录列表的使用:&lt;/font&gt;</div><div class="line">&lt;dir&gt;</div><div class="line">	&lt;li&gt;目录列表选项&lt;/li&gt;</div><div class="line">	&lt;li&gt;目录列表选项&lt;/li&gt;</div><div class="line">&lt;/dir&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>定义列表的嵌套：(在定义列表中，一个<code>&lt;dt&gt;</code>标记下可以有多个<code>&lt;dd&gt;</code>标记作为名词的解释和说明，以实现定义列表的嵌套。)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;font size=&quot;+3&quot; color=&quot;#FF0000&quot;&gt;定义列表的嵌套:&lt;/font&gt;</div><div class="line">&lt;dl&gt;</div><div class="line">	&lt;dt&gt;赠孟浩然&lt;/dt&gt;&lt;br/&gt;</div><div class="line">	&lt;dd&gt;作者：李白&lt;/dd&gt;&lt;br/&gt;</div><div class="line">	&lt;dd&gt;诗体：五言律诗&lt;/dd&gt;&lt;br/&gt;</div><div class="line">	&lt;dd&gt;吾爱孟夫子，风流天下闻。&lt;/dd&gt;</div><div class="line">	&lt;dd&gt;吾爱孟夫子，风流天下闻。&lt;/dd&gt;</div><div class="line">&lt;/dl&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>无序列表和有序列表的嵌套：（最常见的列表嵌套模式，就是有序和无序列表的嵌套，可以重复使用<code>&lt;ol&gt;</code>和<code>&lt;ul&gt;</code>标记组合实现。）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ul type=&quot;circle&quot;&gt;</div><div class="line">	&lt;li type=&quot;square&quot;&gt;入门模式&lt;/li&gt;</div><div class="line">	&lt;li type=&quot;disc&quot;&gt;初级模式&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;ol type=&quot;A&quot; start=&quot;5&quot;&gt;</div><div class="line">	&lt;li&gt;穿越时光术&lt;/li&gt;</div><div class="line">	&lt;li&gt;隐形透明术&lt;/li&gt;</div><div class="line">&lt;/ol&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><ol>
<li>相对链接的使用方法：<ul>
<li>如果链接到同一目录，只需要输入链接文档的名称，如 5-1.html;</li>
<li>如果链接到下一目录下，只需要输入目录名，然后加 “/“ ,再输入文件名，如mr/5-1.html;</li>
<li>如果链接到上一级目录中的文件，则输入”../“，再输入目录名、文件名，如 ../mr/5-2.html;</li>
</ul>
</li>
<li>除了绝对路径和相对路径外，还有一种称为根目录，根目录常常在大规模站点需要放置在几个服务器上，或者一个服务器上放置多个站点时使用，用法只需要以”/“开始表示根目录，之后是文件所在的目录名和文件名，如 /mr/5-1.html;</li>
<li>超链接的建立：<br><code>&lt;a href=&quot;链接地址&quot; target=&quot;目标窗口的打开方式&quot;&gt;链接元素&lt;/a&gt;</code> <ul>
<li><code>href</code>: 目标的链接地址</li>
<li><code>target</code>: 目标窗口的打开方式(<code>_parent</code>、<code>_blank</code>、<code>_self</code>、<code>_top</code>)</li>
</ul>
</li>
<li>书签链接：<ul>
<li>建立书签:<code>&lt;a name=&quot;书签名称&quot;&gt;文字&lt;/a&gt;</code> (<strong>数千名称就是设置连接后要跳转的位置</strong>)    </li>
<li>链接到同一页面的书签：<code>&lt;a href=&quot;#书签名称&quot;&gt;&lt;/a&gt;</code></li>
<li>链接到不同页面的书签: <code>&lt;a href=&quot;链接的文件地址#书签名称&quot;&gt;&lt;/a&gt;</code> </li>
</ul>
</li>
<li>脚本链接：<code>&lt;a href=&quot;javascrip...&quot;&gt;文字链接&lt;/a&gt;</code></li>
<li>空连接：<code>&lt;a href=&quot;#&quot;&gt;文字链接&lt;/a&gt;</code></li>
</ol>
<h4 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h4><ol>
<li><code>&lt;img src=&quot;图片地址&quot; width=&quot;宽度&quot; height=&quot;高度&quot; border=&quot;边框宽度&quot;&gt;</code></li>
<li>图像间距 <code>&lt;img src=&quot;图像地址&quot; hspace=&quot;水平间距&quot; vspace=&quot;垂直间距&quot;&gt;</code></li>
<li>图像的提示文字 <code>&lt;img src=&quot;图像地址&quot; alt=&quot;提示文字内容&quot;&gt;</code> (作用：1.如果图像下载完了，将鼠标放到上面会显示提示文字。2.如果图像没有被下载，在图像的位置就会显示提示文字。)</li>
<li><p>图像相对于文字基准线的对齐方式(align):</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;font size=&quot;+4&quot; color=&quot;#FF66CC&quot;&gt;玫瑰的生长过程&lt;/font&gt;</div><div class="line">&lt;img src=&quot;图片路径&quot; width=&quot;100&quot; height=&quot;100&quot; align=&quot;top&quot;&gt;</div><div class="line">&lt;img src=&quot;图片路径&quot; width=&quot;100&quot; height=&quot;100&quot; align=&quot;middle&quot;&gt;</div><div class="line">&lt;img src=&quot;图片路径&quot; width=&quot;100&quot; height=&quot;100&quot; align=&quot;bottom&quot;&gt;</div><div class="line">&lt;img src=&quot;图片路径&quot; width=&quot;100&quot; height=&quot;100&quot; align=&quot;texttop&quot;&gt;</div><div class="line">&lt;img src=&quot;图片路径&quot; width=&quot;100&quot; height=&quot;100&quot; align=&quot;absmiddle&quot;&gt;</div><div class="line">&lt;img src=&quot;图片路径&quot; width=&quot;100&quot; height=&quot;100&quot; align=&quot;left&quot;&gt;</div><div class="line">&lt;img src=&quot;图片路径&quot; width=&quot;100&quot; height=&quot;100&quot; align=&quot;right&quot;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>图像的超链接：  <code>&lt;a href=&quot;链接地址&quot; target=&quot;目标窗口的打开方式&quot;&gt;&lt;img src=&quot;图片文件的地址&quot;&gt;&lt;/a&gt;</code></p>
</li>
<li><p>设置图像的热区链接：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;链接地址&quot; usemap=&quot;#映射图像名称&quot;&gt;</div><div class="line">&lt;map name=&quot;映射图像名称&quot; id=&quot;..&quot;&gt;</div><div class="line">	&lt;area shape=&quot;热区形状&quot; coords=&quot;热区坐标&quot; href=&quot;链接地址&quot; alt=&quot;描述&quot;&gt;</div><div class="line">	&lt;area shape=&quot;热区形状&quot; coords=&quot;热区坐标&quot; href=&quot;链接地址&quot; alt=&quot;描述&quot;&gt;</div><div class="line">&lt;/map&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>* 在该语法中先定义映射图像的名称，然后再引用这个映射图像。在`&lt;area&gt;`标记中定义了热区的位置和链接；
* 其中 `shape` 用来定义热区的形状，可以取值为 `rect(矩形区域)`、`circle（圆形区域）`以及`poly（多边形区域）`；
* `coords`参数用来设置热区坐标，对于不同的形状，`coords`设置的方式也不同，对于矩形区域rect来说，coords 包含4个参数，分别是 left、top、right、bottom；对于圆形区域 circle来说，coords包含3个参数，分别是 center-x、center-y、tadius，（可理解为圆心x、y和半径的值）；对于多边形poly，与多边形的形状有关。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/03/Git分布式版本控制系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/03/Git分布式版本控制系统/" itemprop="url">
                  Git分布式版本控制系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-03T14:50:58+08:00">
                2017-04-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137402760310626208b4f695940a49e5348b689d095fc000" target="_blank" rel="external">Git教程</a></li>
</ul>
<h3 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h3><ul>
<li>Git是目前世界上最先进的分布式版本控制系统</li>
</ul>
<h3 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h3><ul>
<li>如果你正在使用Mac做开发，有两种安装Git的方法。<ol>
<li>一是安装homebrew，然后通过homebrew安装Git。先打开网站 <a href="http://brew.sh/。" target="_blank" rel="external">http://brew.sh/。</a> 拷贝对应脚本到终端下安装homebrew.然后在终端执行 brew install git命令。</li>
<li>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。  </li>
</ol>
</li>
</ul>
<h3 id="Git-使用"><a href="#Git-使用" class="headerlink" title="Git 使用"></a>Git 使用</h3><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><ul>
<li>首先，选择一个合适的地方，创建一个空目录:(pwd 命令用于显示当前目录)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mkdir learngit</div><div class="line">$ cd learngit</div><div class="line">$ pwd</div><div class="line">/Users/michael/learngit</div></pre></td></tr></table></figure>
<ul>
<li>第二步，通过 <code>git init</code>命令把这个目录变成Git可以管理的仓库：(<code>ls -ah</code>命令可以看到)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git init</div><div class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</div><div class="line">$ ls -ah</div><div class="line">.	..	.git</div></pre></td></tr></table></figure>
<ul>
<li>添加文件到Git仓库，分两步：<ol>
<li>第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；</file></li>
<li>第二步，使用命令git commit，完成。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">localhost:learngit ZZY$ touch readme.txt</div><div class="line">localhost:learngit ZZY$ open readme.txt</div><div class="line">localhost:learngit ZZY$ git add readme.txt</div><div class="line">localhost:learngit ZZY$ git commit -m &quot;wrote a readme file&quot;</div><div class="line">[master (root-commit) c0690a4] wrote a readme file</div><div class="line"> 1 file changed, 3 insertions(+)</div><div class="line"> create mode 100644 readme.txt</div></pre></td></tr></table></figure>
<blockquote>
<p>git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的<br>touch 命令，用于生成一个文件</p>
</blockquote>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>掌握仓库当前的状态：使用 <code>git status</code> 告诉你有文件被修改过，用 <code>git diff</code> 可以查看修改内容。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/02/使用Masonry进行autolayout布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/02/使用Masonry进行autolayout布局/" itemprop="url">
                  使用Masonry进行autolayout布局
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-02T09:15:30+08:00">
                2017-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/e3162f3c61fa" target="_blank" rel="external">代码适配Masonry使用的详细介绍</a></p>
<p><a href="https://my.oschina.net/u/2340880/blog/524859" target="_blank" rel="external">使用第三方库Masonry进行autolayout布局</a></p>
<h4 id="需要导入的框架和宏"><a href="#需要导入的框架和宏" class="headerlink" title="需要导入的框架和宏"></a>需要导入的框架和宏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//define this constant if you want to use Masonry without the &apos;mas_&apos; prefix</div><div class="line">#define MAS_SHORTHAND</div><div class="line">//define this constant if you want to enable auto-boxing for default syntax</div><div class="line">#define MAS_SHORTHAND_GLOBALS</div><div class="line"></div><div class="line">#import &quot;Masonry.h&quot; //宏必须添加在头文件前面</div></pre></td></tr></table></figure>
<h4 id="常用的三种方法"><a href="#常用的三种方法" class="headerlink" title="常用的三种方法"></a>常用的三种方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//这个方法只会添加新的约束</div><div class="line"> [blueView mas_makeConstraints:^(MASConstraintMaker *make)  &#123;&#125;];</div><div class="line">	</div><div class="line"> // 这个方法会将以前的所有约束删掉，添加新的约束</div><div class="line"> [blueView mas_remakeConstraints:^(MASConstraintMaker *make) &#123;&#125;];</div><div class="line">	</div><div class="line"> // 这个方法将会覆盖以前的某些特定的约束</div><div class="line"> [blueView mas_updateConstraints:^(MASConstraintMaker *make) &#123;&#125;];</div></pre></td></tr></table></figure>
<h4 id="常用的约束类型"><a href="#常用的约束类型" class="headerlink" title="常用的约束类型"></a>常用的约束类型</h4><ul>
<li>尺寸：width、height、size </li>
<li>边界：left、leading、right、trailing、top、bottom</li>
<li>中心点：center、centerX、centerY</li>
<li>边界：edges</li>
<li>偏移量：offset、insets、sizeOffset、centerOffset</li>
<li>priority()约束优先级（0~1000），multipler乘因数, dividedBy除因数</li>
</ul>
<h4 id="equalTo-和-mas-equalTo的区别"><a href="#equalTo-和-mas-equalTo的区别" class="headerlink" title="equalTo 和 mas_equalTo的区别"></a>equalTo 和 mas_equalTo的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__)))</div><div class="line">#define mas_greaterThanOrEqualTo(...) greaterThanOrEqualTo(MASBoxValue((__VA_ARGS__)))</div><div class="line">#define mas_lessThanOrEqualTo(...) lessThanOrEqualTo(MASBoxValue((__VA_ARGS__)))</div><div class="line">#define mas_offset(...) valueOffset(MASBoxValue((__VA_ARGS__)))</div></pre></td></tr></table></figure>
<blockquote>
<p>mas_equalTo只是对其参数进行了一个BOX(装箱) 操作，目前支持的类型：数值类型（NSNumber）、 点（CGPoint）、大小（CGSize）、边距（UIEdgeInsets），而equalTo：这个方法不会对参数进行包装。</p>
</blockquote>
<h4 id="更新约束的问题"><a href="#更新约束的问题" class="headerlink" title="更新约束的问题"></a>更新约束的问题</h4><ul>
<li>例如：控制器有个按钮，若是点击按钮，则按钮本身的大小、位置会随机改变</li>
<li>监听按钮点击</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.btn addTarget:self action:@selector(didClickBtn:) forControlEvents:UIControlEventTouchUpInside];</div></pre></td></tr></table></figure>
<ul>
<li>处理事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void) didClickBtn:(UIButton *)button &#123;</div><div class="line">  self.btnSize = CGSizeMake(self.btnSize.width * 1.3, self.btnSize.height * 1.3); //设置一个属性（btnSize）保存其大小的变化</div><div class="line"></div><div class="line">  //1.告知需要更新约束，但不会立刻开始，系统然后调用updateConstraints</div><div class="line">  [self setNeedsUpdateConstraints];</div><div class="line"></div><div class="line">  //2.告知立刻更新约束，系统立即调用updateConstraints</div><div class="line">  [self updateConstraintsIfNeeded];</div><div class="line"></div><div class="line">  //3.这里动画当然可以取消，具体看项目的需求</div><div class="line">  //系统block内引用不会导致循环引用，block结束就会释放引用对象</div><div class="line">  [UIView animateWithDuration:0.4 animations:^&#123;</div><div class="line">      [self layoutIfNeeded]; //告知页面立刻刷新，系统立即调用updateConstraints</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>苹果官方建议：添加/更新约束在这个方法（updateConstraints）内</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// this is Apple&apos;s recommended place for adding/updating constraints</div><div class="line">- (void)updateConstraints &#123;</div><div class="line">   //更新约束</div><div class="line">    [self.btn updateConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.center.equalTo(self);</div><div class="line"></div><div class="line">        make.width.equalTo(@(self.buttonSize.width)).priorityLow();</div><div class="line">        make.height.equalTo(@(self.buttonSize.height)).priorityLow();</div><div class="line"></div><div class="line">        make.width.lessThanOrEqualTo(self);</div><div class="line">        make.height.lessThanOrEqualTo(self);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    //according to apple super should be called at end of method</div><div class="line">    //最后必须调用父类的更新约束</div><div class="line">    [super updateConstraints];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>设置requiresConstraintBasedLayout为YES</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)requiresConstraintBasedLayout&#123;</div><div class="line">    return YES ; //重写这个方法 若视图基于自动布局的</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="多个（2个以上）控件的等间隔排序显示"><a href="#多个（2个以上）控件的等间隔排序显示" class="headerlink" title="多个（2个以上）控件的等间隔排序显示"></a>多个（2个以上）控件的等间隔排序显示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     *  axisType         轴线方向</div><div class="line">     *  fixedSpacing     间隔大小</div><div class="line">     *  fixedItemLength  每个控件的固定长度/宽度</div><div class="line">     *  leadSpacing      头部间隔</div><div class="line">     *  tailSpacing      尾部间隔</div><div class="line">     *</div><div class="line">     */</div><div class="line">//1. 等间隔排列 - 多个控件间隔固定，控件长度/宽度变化</div><div class="line">- (void)mas_distributeViewsAlongAxis:(MASAxisType)axisType</div><div class="line">withFixedSpacing:(CGFloat)fixedSpacing leadSpacing:(CGFloat)leadSpacing</div><div class="line">tailSpacing:(CGFloat)tailSpacing;</div><div class="line"></div><div class="line">//2. 等间隔排列 - 多个固定大小固定，间隔空隙变化</div><div class="line">- (void)mas_distributeViewsAlongAxis:(MASAxisType)axisType</div><div class="line">withFixedItemLength:(CGFloat)fixedItemLength</div><div class="line">leadSpacing:(CGFloat)leadSpacing</div><div class="line">tailSpacing:(CGFloat)tailSpacing;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//首先添加5个视图</div><div class="line"> NSMutableArray *array = [NSMutableArray new];</div><div class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</div><div class="line">        UIView *view = [UIView new];</div><div class="line">        view.backgroundColor = [UIColor greenColor];</div><div class="line">        [self addSubview:view];</div><div class="line">        [array addObject:view]; //保存添加的控件</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//水平方向控件间隔固定等间隔</div><div class="line">[array mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:15 leadSpacing:10 tailSpacing:10];</div><div class="line">            [array makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">                make.top.equalTo(50);</div><div class="line">                make.height.equalTo(70);</div><div class="line">            &#125;];</div><div class="line"></div><div class="line">//水平方向宽度固定等间隔</div><div class="line">[array mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedItemLength:70 leadSpacing:10 tailSpacing:10];</div><div class="line">            [array makeConstraints:^(MASConstraintMaker *make) &#123; //数组额你不必须都是view </div><div class="line">                make.top.equalTo(50);</div><div class="line">                make.height.equalTo(70);</div><div class="line">            &#125;];</div></pre></td></tr></table></figure>
<h4 id="多行label的约束问题"><a href="#多行label的约束问题" class="headerlink" title="多行label的约束问题"></a>多行label的约束问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> //创建label</div><div class="line">    self.label = [UILabel new];</div><div class="line">    self.label.numberOfLines = 0;</div><div class="line">    self.label.lineBreakMode = NSLineBreakByTruncatingTail;</div><div class="line">    self.label.text = @&quot;有的人，没事时喜欢在朋友圈里到处点赞，东评论一句西评论一句，比谁都有存在感。等你有事找他了，他就立刻变得很忙，让你再也找不着。真正的朋友，平常很少联系。可一旦你遇上了难处，他会立刻回复你的消息，第一时间站出来帮你。所谓的存在感，不是你有没有出现，而是你的出现有没有价值。存在感，不是刷出来的，也不是说出来的。有存在感，未必是要个性锋芒毕露、甚至锋利扎人。翩翩君子，温润如玉，真正有存在感的人，反而不会刻意去强调他的存在感。他的出现，永远都恰到好处。我所欣赏的存在感，不是长袖善舞巧言令色，而是对他人的真心关照；不是锋芒毕露计较胜负，而是让人相处得舒服；不是时时刻刻聒噪不休，而是关键时刻能挺身而出。别总急着出风头，希望你能有恰到好处的存在感。&quot;;</div><div class="line">    [self addSubview: self.label];</div><div class="line"></div><div class="line">    [self.label makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.top.equalTo(10);</div><div class="line">        make.right.equalTo(-10);</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">//添加约束</div><div class="line">- (void)layoutSubviews &#123;</div><div class="line">    //1. 执行 [super layoutSubviews];</div><div class="line">    [super layoutSubviews];</div><div class="line"></div><div class="line">    //2. 设置preferredMaxLayoutWidth: 多行label约束的完美解决</div><div class="line">   self.label.preferredMaxLayoutWidth = [UIScreen mainScreen].bounds.size.width - 20;</div><div class="line"></div><div class="line">    //3. 设置preferredLayoutWidth后，需要再次执行 [super layoutSubviews]; </div><div class="line">    //其实在实际中这步不写，也不会出错，官方解释是说设置preferredLayoutWidth后需要重新计算并布局界面，所以这步最好执行</div><div class="line">    [super layoutSubviews];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UIScrollView-的问题"><a href="#UIScrollView-的问题" class="headerlink" title="UIScrollView 的问题"></a>UIScrollView 的问题</h4><ul>
<li>原理同自动布局一样 UIScrollView上添加UIView<br>UIView上添加需要显示的控件 UIScrollView滚动高度取决于显示控件的总高度<br>对子控件做好约束，可达到控制UIView的大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//创建滚动视图</div><div class="line">UIScrollView *scrollView = [UIScrollView new];</div><div class="line">self.scrollView = scrollView;</div><div class="line">	</div><div class="line">scrollView.backgroundColor = [UIColor grayColor];</div><div class="line">[self addSubview:scrollView];</div><div class="line">	</div><div class="line">[self.scrollView makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.edges.equalTo(self);</div><div class="line">&#125;];</div><div class="line">	</div><div class="line">[self setUpContentView]; //添加内容视图</div><div class="line">	</div><div class="line">- (void)setUpContentView &#123;</div><div class="line">//约束UIScrollView上contentView</div><div class="line">UIView *contentView = [UIView new];</div><div class="line">[self.scrollView addSubview:contentView];</div><div class="line">	</div><div class="line">[contentView makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.edges.equalTo(self.scrollView);</div><div class="line">    make.width.equalTo(self.scrollView); //此处必填 - 关键点</div><div class="line">&#125;];</div><div class="line">	</div><div class="line">//添加控件到contentView，约束原理与自动布局相同</div><div class="line">UIView *lastView;</div><div class="line">CGFloat height = 30;</div><div class="line">for (int i = 0; i &lt;1 5; i ++) &#123;</div><div class="line">    UIView *view = UIView.new;</div><div class="line">    view.backgroundColor = [UIColor colorWithRed:arc4random() % 255 / 256.0  green:arc4random() % 255 / 256.0 blue:arc4random() % 255 / 256.0 alpha:1.0];</div><div class="line">    [contentView addSubview:view];</div><div class="line">	</div><div class="line">    [view makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.top.equalTo(lastView ? lastView.bottom : @0);</div><div class="line">        make.left.equalTo(0);</div><div class="line">        make.width.equalTo(contentView.width);</div><div class="line">        make.height.equalTo(height);</div><div class="line">    &#125;];</div><div class="line">	</div><div class="line">    height += 30;</div><div class="line">    lastView = view;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">[contentView makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.bottom.equalTo(lastView.bottom);</div><div class="line">    &#125;];</div><div class="line">	&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/19/SDWebImage源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/19/SDWebImage源码/" itemprop="url">
                  SDWebImage源码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-19T22:59:05+08:00">
                2017-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="UIImageView-WebCache-h"><a href="#UIImageView-WebCache-h" class="headerlink" title="UIImageView+WebCache.h"></a>UIImageView+WebCache.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">- (void)sd_setImageWithPreviousCachedImageWithURL:(nullable NSURL *)url</div><div class="line">                                 placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                                          options:(SDWebImageOptions)options</div><div class="line">                                         progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                        completed:(nullable SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<blockquote>
<p>上面这些方法统一调用的是下面这个主方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<blockquote>
<p>此方法通过调用 <code>UIView+WebCache.h</code> 中的 <code>sd_internalSetImageWithURL：...</code>来实现。</p>
</blockquote>
<h4 id="UIView-WebCache-h"><a href="#UIView-WebCache-h" class="headerlink" title="UIView+WebCache.h"></a>UIView+WebCache.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//返回请求的URL</div><div class="line">- (nullable NSURL *)sd_imageURL;</div><div class="line">//通过 SDWebImageManager 来获取请求的图片，可能在缓存中、可能需要下载</div><div class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</div><div class="line">                  placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(nullable NSString *)operationKey</div><div class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">//取消当前类的Image请求</div><div class="line">- (void)sd_cancelCurrentImageLoad;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageManager-h"><a href="#SDWebImageManager-h" class="headerlink" title="SDWebImageManager.h"></a>SDWebImageManager.h</h4><ul>
<li>SDWebImageManager 通过 <code>sahredManager</code> 单例获取当前对象</li>
<li>并在其初始化方法中获取到 <code>SDImageCache</code> 缓存 和<code>SDWebImageloader</code> 下载 两个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (nonnull instancetype)init &#123;</div><div class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</div><div class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</div><div class="line">    return [self initWithCache:cache downloader:downloader];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _imageCache = cache;</div><div class="line">        _imageDownloader = downloader;</div><div class="line">        _failedURLs = [NSMutableSet new];</div><div class="line">        _runningOperations = [NSMutableArray new];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过下列方法来获取图片： 通过 <code>_imageCache</code> 对象判断缓存中是否存在此图片，若有则返回，若没有则通过 <code>_imageDownloader</code> 对象去服务器下载此图片。         </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</div><div class="line">                                              options:(SDWebImageOptions)options</div><div class="line">                                             progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                            completed:(nullable SDInternalCompletionBlock)completedBlock</div></pre></td></tr></table></figure>
<h4 id="SDImageCache-h"><a href="#SDImageCache-h" class="headerlink" title="SDImageCache.h"></a>SDImageCache.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//获取当前对象</div><div class="line">+ (nonnull instancetype)sharedImageCache;</div><div class="line"></div><div class="line">//通过 key 在缓存中查找对应的图片</div><div class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageDownloader-h"><a href="#SDWebImageDownloader-h" class="headerlink" title="SDWebImageDownloader.h"></a>SDWebImageDownloader.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//获取当前SDWebImageDownloader对象</div><div class="line">+ (nonnull instancetype)sharedDownloader</div><div class="line"></div><div class="line">//通过此方法从服务器下载图片</div><div class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock</div></pre></td></tr></table></figure>
<h4 id="SDWebImageDownloaderOperation-h"><a href="#SDWebImageDownloaderOperation-h" class="headerlink" title="SDWebImageDownloaderOperation.h"></a>SDWebImageDownloaderOperation.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//初始化一个 SDWebImageDownloaderOperation 对象</div><div class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</div><div class="line">                              inSession:(nullable NSURLSession *)session</div><div class="line">                                options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">//添加 下载进度和下载完成的 block 回调</div><div class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</div><div class="line"></div><div class="line">// 通过 token 取消当前下载</div><div class="line">- (BOOL)cancel:(nullable id)token;</div></pre></td></tr></table></figure>
<h4 id="UIView-WebCacheOperation-h"><a href="#UIView-WebCacheOperation-h" class="headerlink" title="UIView+WebCacheOperation.h"></a>UIView+WebCacheOperation.h</h4><ul>
<li>本类主要用于 operation 对象的管理,当一个对象（UIImageView）被重复请求时，将会把第一次的 operation cancel 掉，将新的 operation 加入到 operationDictionary 字典中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//获取 NSMutableDictionary 类型的 operationDictionary</div><div class="line">- (SDOperationsDictionary *)operationDictionary;</div><div class="line"></div><div class="line">//通过 key 值将 operation 对象存入 operationDictionary 字典中</div><div class="line">- (void)sd_setImageLoadOperation:(nullable id)operation forKey:(nullable NSString *)key;</div><div class="line"></div><div class="line">//通过 key 标识 取消operation请求</div><div class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key;</div><div class="line"></div><div class="line">//通过 key 标识 将 operation 对象从operationDictionary字典中删除</div><div class="line">- (void)sd_removeImageLoadOperationWithKey:(nullable NSString *)key;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/17/iOS 并发编程之 Operation Queues /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/iOS 并发编程之 Operation Queues /" itemprop="url">
                  iOS并发编程之OperationQueues
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:14:05+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li>进程（process）：指的是一个正在运行中的可执行文件，每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程。另外，当一个进程的主线程退出时，这个进程就结束了。</li>
<li>线程（thread）：指的是一个独立的代码执行路径。</li>
<li>任务（task）：指的是我们需要执行的工作，是一个抽象的概念，用通俗点的话说，就是一段代码。</li>
</ul>
<h4 id="串行-VS-并发"><a href="#串行-VS-并发" class="headerlink" title="串行 VS 并发"></a>串行 VS 并发</h4><p>从本质上来讲，串行和并发的主要区别在于允许同时执行的任务数量，串行，指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；并发，指的是允许多个任务同时执行。</p>
<h4 id="同步-VS-异步"><a href="#同步-VS-异步" class="headerlink" title="同步 VS 异步"></a>同步 VS 异步</h4><p>同步和异步操作的主要区别在于是否等待操作的完成，亦即是否阻塞当前线程。同步操作会等待操作执行完成后继续执行接下来的代码，而异步操作则恰好相反，它会在调用后立即返回，不会等待操作的执行结果。</p>
<h4 id="队列-VS-线程"><a href="#队列-VS-线程" class="headerlink" title="队列 VS 线程"></a>队列 VS 线程</h4><p>在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。</p>
<h3 id="iOS-的并发编程模型"><a href="#iOS-的并发编程模型" class="headerlink" title="iOS 的并发编程模型"></a>iOS 的并发编程模型</h3><h4 id="Operation-Queues-VS-GCD"><a href="#Operation-Queues-VS-GCD" class="headerlink" title="Operation Queues VS GCD"></a>Operation Queues VS GCD</h4><p>CGD 是苹果基于 C 语言开发的，一个用于多核编程的解决方案，主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。而 Operation Queues 则是一个建立在 GCD 基础之上的，面向对象的解决方案，它使用起来比 GCD 更加灵活，功能更强大。</p>
<ul>
<li>Operation Queues：相对 GCD 来说，使用 Operation Queues 会增加一点点额外的开销，但是我们却换来了非常强大的灵活性和功能，我们可以给 operation 添加依赖关系、取消一个正在执行的 Operation 、暂停和恢复 Operation queue等</li>
<li>GCD ：则是一种更轻量级的，以 FIFO 的顺序执行并发任务的方式，使用 GCD 时我们并不关心任务的调度情况，而让系统帮我们自动处理。但是 GCD 的短板也是非常明显的，比如我们想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得非常棘手。</li>
</ul>
<h3 id="关于-Operation-对象"><a href="#关于-Operation-对象" class="headerlink" title="关于 Operation 对象"></a>关于 Operation 对象</h3><p>NSOperation 本身是一个抽象类，不能直接实例化，因此如果我们想要使用它来执行具体的任务的话，就必须创建子类或者使用系统预定义的两个子类，NSInvocationOperation 和 NSBlockOperation。</p>
<h4 id="Operation-支持的特性"><a href="#Operation-支持的特性" class="headerlink" title="Operation 支持的特性"></a>Operation 支持的特性</h4><ul>
<li>支持在 Operation 之间建立依赖关系，只有当一个 Operation 所依赖的所有的 Operation 都执行完成时，这个 Operation 才能开始执行;</li>
<li>支持一个可选的 completion block ，这个 block 将会在 Operation 的主任务执行完成时被调用。</li>
<li>支持通过 kvo 来观察 Operation 执行的状态变化。</li>
<li>支持设置执行的优先级，从而影响 Operation 之间的相对执行顺序。</li>
<li>支持取消操作，可以允许我们停止正在执行的 Operation。</li>
</ul>
<h4 id="创建-NSInvocationOperation-和-NSBlockOperation"><a href="#创建-NSInvocationOperation-和-NSBlockOperation" class="headerlink" title="创建 NSInvocationOperation 和 NSBlockOperation"></a>创建 NSInvocationOperation 和 NSBlockOperation</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (NSInvocationOperation *) invocationOperationWithData:(id)data &#123;</div><div class="line">    return [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(p_myRaskMethod:) object:data];</div><div class="line">&#125;</div><div class="line">- (NSBlockOperation*) blockOperationWithData:(id)data &#123;</div><div class="line">    NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        NSLog(@&quot;Finsh executing block1&quot;);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [blockOperation addExecutionBlock:^&#123;</div><div class="line">         NSLog(@&quot;Finsh executing block2&quot;);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [blockOperation addExecutionBlock:^&#123;</div><div class="line">         NSLog(@&quot;Finsh executing block3&quot;);</div><div class="line">    &#125;];</div><div class="line">    return blockOperation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method</div><div class="line">- (void)p_myRaskMethod:(id)data &#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="自定义-Operation-对象"><a href="#自定义-Operation-对象" class="headerlink" title="自定义 Operation 对象"></a>自定义 Operation 对象</h4><p>每一个 Operation 至少需要实现两个方法：</p>
<ul>
<li>一个自定义的初始化方法</li>
<li>main 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@implementation EXOChildOperation</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123; &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)main &#123;</div><div class="line">    @try &#123;</div><div class="line">        if (self.isCancelled) return;</div><div class="line">        //要执行的任务</div><div class="line">        NSLog(@&quot;任务==Start-%@-%@&quot;,[NSThread currentThread],[NSThread mainThread]);</div><div class="line">        for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">            if (self.isCancelled) return;</div><div class="line">            sleep(2);   //模拟任务</div><div class="line">        &#125;</div><div class="line">        NSLog(@&quot;任务==完成&quot;);</div><div class="line">    &#125; @catch (NSException *exception) &#123;</div><div class="line">        NSLog(@&quot;%s%@&quot;,__func__,exception);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">``` </div><div class="line">&gt; 要相应 cancel 事件，需要在代码中定期检查 `isCanceled` 方法的返回值</div><div class="line"></div><div class="line">#### 配置并发执行的 Operation</div><div class="line">默认情况下，Operation 是同步执行的，在调用 `start` 方法的线程中执行他们的任务，如果 Operation 和 Operation queue 结合使用，operation queue 可以为**非并发**Operation 提供线程，因此 大部分的 Operation 仍然可以异步执行。</div><div class="line"></div><div class="line">需要重写的方法：</div><div class="line">- `start` 必须重写，特别注意不要在我们重写的 `start` 方法中调用父类的实现。</div><div class="line">- `main`	可选的，通常这个方法就是专门用来实现与该 operation 相关联的任务的。</div><div class="line">- `isExecuting`和`isFinished` 必须的， 此外，当这两个方法所代表的值发生变化时，我们需要生成相应的 KVO 通知，以便外界能够观察到这些状态的变化</div><div class="line">- `isAsynchronous` 必须的，这个方法的返回值用来标识一个 operation 是否是并发的 operation ，我们需要重写这个方法并返回 YES 。</div></pre></td></tr></table></figure>
<p>//  配置 并发 的 Operation</p>
<p>#import “EXOParallelOperation.h”</p>
<p>@interface EXOParallelOperation (){<br>    BOOL executing; //是否执行中<br>    BOOL finished;  //是否完成<br>}</p>
<p>@end</p>
<p>@implementation EXOParallelOperation</p>
<ul>
<li><p>(instancetype)init<br>{<br>  self = [super init];<br>  if (self) {</p>
<pre><code>executing = NO;
finished  = NO;
</code></pre><p>  }<br>  return self;<br>}</p>
</li>
<li><p>(void)start {<br>  if ([self isCancelled]) {</p>
<pre><code>[self willChangeValueForKey:@&quot;isFinished&quot;];
finished = YES;
[self didChangeValueForKey:@&quot;isFinished&quot;];
return;
</code></pre><p>  }</p>
<p>  [self willChangeValueForKey:@”isExecuting”];<br>  [NSThread detachNewThreadWithBlock:^{</p>
<pre><code>[self main];
</code></pre><p>  }];<br>  executing = YES;<br>  [self didChangeValueForKey:@”isExecuting”];<br>}</p>
</li>
<li><p>(BOOL)isExecuting {<br>  return executing;<br>}</p>
</li>
<li><p>(BOOL)isFinished {<br>  return finished;<br>}</p>
</li>
</ul>
<p>/**<br> 是否并发执行</p>
<p> @return Y 并发 N 非并发<br> */</p>
<ul>
<li><p>(BOOL)isAsynchronous {<br>  return YES;<br>}</p>
</li>
<li><p>(void)main {<br>  @try {</p>
<pre><code>@autoreleasepool {
    BOOL taskIsFinished = NO;
    while (!taskIsFinished &amp;&amp; ![self isCancelled]) {
        //自定义 操作
        sleep(2);
        taskIsFinished = YES;
        NSLog(@&quot;currentThread = %@, main = %@&quot;,[NSThread currentThread],[NSThread mainThread]);
    }
    [self completeOperation];

}
</code></pre><p>  } @catch (NSException *exception) {</p>
<p>  }<br>}</p>
</li>
<li><p>(void)completeOperation {<br>  [self willChangeValueForKey:@”isFinished”];<br>  [self willChangeValueForKey:@”isExecuting”];</p>
<p>  executing = NO;<br>  finished = YES;</p>
<p>  [self didChangeValueForKey:@”isExecuting”];<br>  [self didChangeValueForKey:@”isFinished”];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; 注意，有一个非常重要的点需要引起我们的注意，那就是即使一个 operation 是被 cancel 掉了，我们仍然需要手动触发 isFinished 的 KVO 通知。因为当一个 operation 依赖其他 operation 时，它会观察所有其他 operation 的 isFinished 的值的变化，只有当它依赖的所有 operation 的 isFinished 的值为 YES 时，这个 operation 才能够开始执行。因此，如果一个我们自定义的 operation 被取消了但却没有手动触发 isFinished 的 KVO 通知的话，那么所有依赖它的 operation 都不会执行。</div><div class="line"></div><div class="line">### 定制 Operation 对象的执行行为</div><div class="line"></div><div class="line">#### 配置依赖关系</div><div class="line">通过配置依赖关系，我们可以让不同的 Operation 串行执行，一个 operation 只有在它依赖的所有 operation 都执行完成后才能开始执行。</div></pre></td></tr></table></figure>
</li>
<li><p>(void)addDependency:(NSOperation *)op;</p>
</li>
<li>(void)removeDependency:(NSOperation *)op;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 就是不要在 operation 之间添加循环依赖，因为这样会导致这些 operation 都不会被执行。</div><div class="line">&gt; 我们应该在手动执行一个 operation 或将它添加到 operation queue 前配置好依赖关系，因为在之后添加的依赖关系可能会失效。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>NSOperationQueue <em>operationQueue = [[NSOperationQueue alloc] init];<br>[operationQueue setMaxConcurrentOperationCount:2];  //设置最大并发数<br>EXOParallelOperation </em>operation = [[EXOParallelOperation alloc] init];<br>EXOChildOperation *operation2 = [[EXOChildOperation alloc] init];<br>//添加到 operation queue 前配置好依赖关系 operation2 依赖于 operation<br>[operation2 addDependency:operation];<br>[operationQueue addOperation:operation];<br>[operationQueue addOperation:operation2];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#### 修改Operation 在队列中的优先级</div><div class="line">对于添加到 Operation queue 中的 Operation 来说，决定它们执行顺序的第一要素是它们的 `isReady` 状态，其次是它们在队列中的优先级，Operation 的 `isReady` 状态取决于它们的依赖关系，而都在队列中的优先级则是 Operation 本身的属性。默认新创建的 Operation 的优先级都为 `normal` 的,**但是我们可以通过 `setQueuePriority:` 方法来提高或降低 Operation 在队列中的优先级**。</div><div class="line"></div><div class="line">需要注意的是：**队列的优先级只应用在相同的 Operation queue 中的 Operation 之间，不同的 Operation queue 不受此影响**。</div><div class="line"></div><div class="line">#### 修改 Operation 执行任务线程的优先级</div><div class="line"></div><div class="line">* 从 iOS4.0 开始，我们可以修改 operation 的执行任务线程的优先级，我们可以给 Operation 的线程指定一个从 `0.0` 到 `1.0` 的浮点数值，`0.0` 表示最低的优先级，`1.0` 表示最高的优先级，默认值为 `0.5` 。</div><div class="line">* 注意：**我们只能够在执行一个 Operation 或将其添加到 Operation queue 前，通过 Operation 的 `setThreadPriority:` 方法来修改它的线程优先级**。另外，我们指定的这个线程优先级只会影响 main 方法执行时所在线程的优先级。*所有其它的代码，包括 operation 的 completion block 所在的线程会一直以默认的线程优先级执行*。**因此，当我们自定义一个并发的 operation 类时，我们也需要在 start 方法中根据指定的值自行修改线程的优先级**</div><div class="line"></div><div class="line">#### 设置 Completion Block</div><div class="line">1. 一个 Operation 可以在它的主任务执行完成时回调一个 completion block。直接调用 Operation 的 `setCompletionBlock：` 方法即可。</div><div class="line">2. 注意，当一个 Operation 被取消时，它的 completion block 仍然会被调用，**所以我们需要在真正执行代码前检查一下 isCancelled 方法的返回值，如果有必要的话我们可以在 completion block 中使用 GCD 来保证从主线程更新 UI** </div><div class="line"></div><div class="line">### 执行 Operation 对象</div><div class="line">* 将 operation 添加到 Operation queue 中，让 Operation queue 来帮助我们自动执行；</div><div class="line">* 直接调用 `start` 方法手动执行 Operation；</div><div class="line"></div><div class="line">#### 添加 Operation 到 Operation queue 中</div><div class="line">`NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];`</div><div class="line"></div><div class="line">创建好 Operation queue 后，我们有三种方法添加 Operation 到 Operation queue 中：</div><div class="line"></div><div class="line">* `addOperation:` 添加一个 Operation 到 Operation queue 中；</div><div class="line">* `addOperation: waitUntilFinished:` 添加一组 Operation 到 Operation queue 中；</div><div class="line">* `addOperationWithBlock:` 直接添加一个 block 到 Operation queue 中，而不用创建一个 `NSBlockOperation` 对象；</div><div class="line"></div><div class="line">在大多数情况下，一个 operation 被添加到 operation queue 后不久就会执行，但是也有很多原因会使 operation queue 延迟执行入队的 operation 。比如，我们前面提到了的，如果一个 operation 所依赖的其他 operation 还没有执行完成时，这个 operation 就不能开始执行；再比如说 operation queue 被暂停执行或者已经达到了它最大可并发的 operation 数。下面的示例代码展示了这三种方法的基本用法：</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)executeOperationUsingOperationQueue {<br>  NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];</p>
<p>  NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(taskMethod) object:nil];<br>  [operationQueue addOperation:invocationOperation];</p>
<p>  NSBlockOperation *blockOperation1 = [NSBlockOperation blockOperationWithBlock:^{</p>
<pre><code>NSLog(@&quot;Start executing blockOperation1, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);
sleep(3);
NSLog(@&quot;Finish executing blockOperation1&quot;);
</code></pre><p>  }];</p>
<p>  NSBlockOperation *blockOperation2 = [NSBlockOperation blockOperationWithBlock:^{</p>
<pre><code>NSLog(@&quot;Start executing blockOperation2, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);
sleep(3);
NSLog(@&quot;Finish executing blockOperation2&quot;);
</code></pre><p>  }];</p>
<p>  [operationQueue addOperations:@[ blockOperation1, blockOperation2 ] waitUntilFinished:NO];</p>
<p>  [operationQueue addOperationWithBlock:^{</p>
<pre><code>NSLog(@&quot;Start executing block, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);
sleep(3);
NSLog(@&quot;Finish executing block&quot;);
</code></pre><p>  }];</p>
<p>  [operationQueue waitUntilAllOperationsAreFinished];<br>}<br>``` </p>
</li>
</ul>
<ul>
<li>尽管 NSOperationQueue 类被设计成用来并发执行 operation 的，但是我们可以强制一个 operation queue 一次只执行一个 operation 。我们可以通过 <code>setMaxConcurrentOperationCount:</code> 方法来设置一个 operation queue 的最大并发的 operation 数。将值设置成 1 就可以实现让 operation queue 一次只执行一个 operation 的目的。</li>
<li>operation 的执行顺序还是会受到其他因素的影响，比如 operation 的 <code>isReady</code> 状态、operation 的队列优先级等。 </li>
<li>因此，一个穿行的 operation queue 与一个串行的 dispatch queue 还是有本质区别的，因为 dispatch queue 的执行顺序一直是 <code>FIFO</code> 的。如果 operation 的执行顺序对我们来说很重要，那么我们就应该在将 operation 添加到 operation queue 之前，就建立好它的依赖关系。</li>
</ul>
<h4 id="取消-Operation"><a href="#取消-Operation" class="headerlink" title="取消 Operation"></a>取消 Operation</h4><ul>
<li>当一个 operation 被添加到 operation queue 中后，这个 operation 的所有权就属于这个 operation queue 了，并且不能被移除。</li>
<li>唯一从 operation queue 中出队一个 operation 的方式就是调用它的 <code>cancel</code> 方法取消这个 operation ，或者调用 operation queue 的 <code>cancelAllOperations</code> 方法取消这个 Operation queue 中全部的 Operation。</li>
<li>当一个 Operation 被取消后，这个 Operation 的 <code>isFinished</code> 状态也会变成 <code>YES</code>，这样做的好处是所有依赖它的 Operation 能接收到这个 <code>KVO</code> 通知，从而能够清除这个依赖关系。</li>
</ul>
<h4 id="等待-Operation-执行完成"><a href="#等待-Operation-执行完成" class="headerlink" title="等待 Operation 执行完成"></a>等待 Operation 执行完成</h4><ul>
<li>我们可以调用 NSOperation 类的 <code>waitUntilFinished</code> 方法来阻塞当前线程，直到这个 Operation 执行完成。</li>
<li>除了等待一个单独的 operation 执行完成外，我们也可以通过调用 NSOperationQueue 的<code>waitUntilAlloperationsAreFinished</code> 方法来等待 operation queue 中的所有 operation 执行完成。</li>
<li>当我们在等待一个 operation queue 中的所有 operation 执行完成时，其他的线程仍然可以向这个 operation queue 中添加 operation ，从而延长我们的等待时间。</li>
</ul>
<h4 id="暂停和恢复-Operation-Queue"><a href="#暂停和恢复-Operation-Queue" class="headerlink" title="暂停和恢复 Operation Queue"></a>暂停和恢复 Operation Queue</h4><ul>
<li>我们可以通过 Operation queue 的 <code>setSuspended:</code> 方法实现队列的暂停和恢复。</li>
<li>暂停执行 operation queue <strong>并不能使正在执行的 operation 暂停执行，而只是简单地暂停调度新的 operation</strong>。</li>
<li><strong>不能单独暂停执行一个 operation，除非直接 <code>cancel</code> 掉</strong>。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/iOS与OSX 多线程与内存管理第三章：GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/iOS与OSX 多线程与内存管理第三章：GCD/" itemprop="url">
                  iOS与OSX 多线程与内存管理第三章：GCD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T19:27:03+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h3><ul>
<li>Dispatch Queue 按照追加的顺序（先进先出 FIFO，First-In-First-Out）执行处理。在执行处理时存在两种 Dispatch Queue，<strong>一种是等待现在执行中处理的 Serial Dispatch Queue，另一种是不等待现在执行中处理的 Concurrent Dispatch Queue</strong>。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.zzy.gcd.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">//创建并发队列</div><div class="line">dispatch_queue_t concurrenyQueue = dispatch_queue_create(&quot;com.zzy.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<ul>
<li>当多线程更新相同资源导致数据竞争时使用 Serial Dispatch Queue 。</li>
<li>Main Dispatch Queue 是在主线程中执行的 Dispatch Queue，因为主线程只有一个，所以 Main Dispatch Queue 自然就是 Serial Dispatch Queue。</li>
<li>Global Dispatch Queue 是所有的应用程序都能够使用的 Concurrent Dispatch Queue。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Main Dispatch Queue 的获取方法</div><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">//Global Dispatch Queue 的获取方法</div><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>
<ul>
<li>使用 <code>dispatch_set_target_queue</code> 更改 Dispatch Queue 的执行优先级 <a href="http://www.cnblogs.com/denz/archive/2016/02/24/5214297.html" target="_blank" rel="external">用法</a></li>
</ul>
<h3 id="Dispatch-after"><a href="#Dispatch-after" class="headerlink" title="Dispatch_after"></a>Dispatch_after</h3><ul>
<li>dispatch_after 并不是在指定的时间后执行处理，而只是在指定的时间追加处理到 Dispatch Queue。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</div><div class="line">    dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;1 sec 将其添加到main队列&quot;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p><code>DISPATCH_TIME_NOW</code> 表示现在的时间、<code>NSEC_PER_SEC</code>和秒为乘积、<code>NSEC_PER_MSEC</code>和毫秒为乘积。</p>
</blockquote>
<h3 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h3><ul>
<li>在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，第一种方式 使用 Serial Dispatch Queue ，将想要执行的处理全部追加到该 Serial Dispatch Queue 中并在最后追加结束处理，即可实现。 第二种方式 <strong>在使用 Concurrent Dispatch Queue 时或同时使用多个 Dispatch Queue 时，使用 Dispatch Group</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    NSLog(@&quot;block0&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    NSLog(@&quot;block1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;done&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>另外，在 Dispatch Group 中也可以使用 <code>dispatch_group_wait</code> 函数仅等待全部处理执行结束。</li>
</ul>
<p><code>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</code></p>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a><code>dispatch_barrier_async</code></h3><ul>
<li>在访问数据库或者文件的时候，写入操作不可与其它写入操作并行执行，但读取处理只是与读取处理并行执行，是没有问题的。</li>
<li><code>dispatch_barrier_async</code> 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束后，再将指定的处理追加到该 Concurrent Dispatch Queue 中，在其执行完成之后，Concurrent Dispatch Queue 才又开始处理后续的并行执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(queue, blk0_for_reading);</div><div class="line">dispatch_async(queue, blk1_for_reading);</div><div class="line">dispatch_async(queue, blk2_for_reading);</div><div class="line">dispatch_async(queue, blk3_for_reading);</div><div class="line">dispatch_barrier_async(queue, blk_for_writing);</div><div class="line">dispatch_async(queue, blk4_for_reading);</div><div class="line">dispatch_async(queue, blk5_for_reading);</div><div class="line">dispatch_async(queue, blk6_for_reading);</div></pre></td></tr></table></figure>
<ul>
<li><code>dispatch_barrier_async</code>和<code>dispatch_barrier_sync</code>的区别在于是否等待当前任务执行完成后再将后续的任务添加到 Dispatch Queue 中。</li>
</ul>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a><code>dispatch_apply</code></h3><ul>
<li>该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_apply(5, queue, ^(size_t index) &#123;</div><div class="line">    NSLog(@&quot;index = %li&quot;,index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;done&quot;);</div></pre></td></tr></table></figure>
<blockquote>
<p>该源代码的执行结果：（各个处理的时常不一定，但done必定在最后的位置上）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">2</div><div class="line">3</div><div class="line">1</div><div class="line">4</div><div class="line">done</div></pre></td></tr></table></figure>
<ul>
<li>另外，由于 <code>dispatch_apply</code> 函数也与 <code>dispatch_sync</code> 函数相同，会等待处理执行结束，<strong>因此推荐在 <code>dispatch_async</code>函数中非同步的执行 <code>dispatch_apply</code> 函数</strong>。</li>
</ul>
<h3 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a><code>dispatch_suspend / dispatch_resume</code></h3><ul>
<li>当追加大量处理到 Dispatch Queue 时，在追加处理的过程中，有时希望不执行已追加的处理。例如演算结果被 Block 截获时，一些处理会对这个演算结果造成影响。</li>
<li><code>dispatch_suspend</code> 函数挂起指定的 Dispatch Queue <code>dispatch_suspend(queue);</code></li>
<li><code>dispatch_resume</code> 函数恢复指定的 Dispatch Queue <code>dispatch_resume(queue);</code></li>
<li>这些函数对已经执行的函数没有影响。挂起后，追加到队列中但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</li>
</ul>
<h3 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h3><ul>
<li>当并行执行的处理更新数据时，会产生数据不一致的情况，有时程序还会异常结束。虽然使用 Serial Dispatch Queue 和 <code>dispatch_barrier_async</code> 函数可以避免这类问题，但有必要进行耕细粒度的排他控制。</li>
<li>Dispatch Semaphore 是持有计数的信号，当计数为 0 时等待，计数为 1 或大于 1 时，减去 1 而不等待。</li>
<li>主要有三个函数：<ol>
<li>初始化信号量：  <code>dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</code></li>
<li>当信号量计数为 1 或大于 1 时，减去 1 而不等待，否则等待：   <code>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</code></li>
<li>将 Dispatch Semaphore 的计数 +1：  <code>dispatch_semaphore_signal(semaphore);</code></li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">/*</div><div class="line"> *  生成 Dispatch Semaphore</div><div class="line"> *</div><div class="line"> *  Dispatch Semaphore 的计数初始值设定为 “1” 以保证可访问 NSMutableArray 类 对象的线程同时只能有一个。</div><div class="line"> */</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</div><div class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">for (int i = 0; i &lt; 10000; i++) &#123;</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        /*</div><div class="line">         *  等待 Dispatch Semaphore</div><div class="line">         *  一直等待直到 Dispatch Semaphore 的计数值达到大于等于 1</div><div class="line">         */</div><div class="line">        </div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        </div><div class="line">        /*</div><div class="line">         *  由于 Dispatch Semaphore 的计数值大于等于 1</div><div class="line">         *  dispatch_semaphore_wait 使计数值减去 1 </div><div class="line">         *</div><div class="line">         *  执行到此时 Dispatch Semaphore 的计数恒为 “0”  </div><div class="line">         *  由于可访问 NSMutableArray 类对象的线程数只有1个，因此可安全的进行更新。</div><div class="line">         */</div><div class="line">        </div><div class="line">        [array addObject:[NSNumber numberWithInt:i]];</div><div class="line">        </div><div class="line">        /*</div><div class="line">         *  排他控制处理结束</div><div class="line">         *  通过 dispatch_semaphore_signal 函数将 Dispatch Semaphore 的计数 +1</div><div class="line">         *</div><div class="line">         **/</div><div class="line">        </div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a><code>dispatch_once</code></h3><ul>
<li><code>dispatch_once</code> 函数是保证在应用程序执行中只执行一次指定处理的 API。使用dispatch_once 可以简化代码并且彻底保证线程安全，开发者无需担心加锁或同步，而且执行效率更高。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+(instancetype)sharedInstance&#123;   </div><div class="line">    static Singleton *sharedSingleton = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        sharedSingleton = [[Singleton alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return  sharedSingleton;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)sharedInstance &#123;</div><div class="line">    static ViewController *controller = nil;</div><div class="line">    @synchronized (self) &#123;</div><div class="line">        if (!controller) &#123;</div><div class="line">            controller = [ViewController new];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return controller;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h3><ul>
<li>在读取较大文件时，如果将文件分成合适的大小并使用Global Dispatch Queue并列读取的话，应该会比一般的读取速度快不少。现今的输入/输出硬件已经可以做到一次使用多个线程更快地并列读取了。能实现这一功能的就是Dispatch I/O和Dispatch Data。<br>通过Dispatch I/O读写文件时，使用Global Dispatch Queue将一个文件按大小read/write。</li>
</ul>
<h3 id="Dispatch-Source-定时器"><a href="#Dispatch-Source-定时器" class="headerlink" title="Dispatch Source (定时器)"></a>Dispatch Source (定时器)</h3><ul>
<li>NSTimer受runloop的影响，由于runloop需要处理很多任务，导致NSTimer的精度降低，在日常开发中，如果我们需要对定时器的精度要求很高的话，可以考虑dispatch_source_t去实现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">//设置开始时间 2s 后，时间间隔 1s</div><div class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class="line">dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">    NSLog(@&quot;----self.timer---&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_resume(timer);</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/iOS与OSX 多线程与内存管理第二章：Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/iOS与OSX 多线程与内存管理第二章：Block/" itemprop="url">
                  iOS与OSX 多线程与内存管理第二章：Block
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T19:26:14+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Blocks-概要"><a href="#Blocks-概要" class="headerlink" title="Blocks 概要"></a>Blocks 概要</h3><ul>
<li>Blocks 是 C 语言的扩展功能，其定义为：<strong>带有自动变量（局部变量）的匿名函数</strong>。</li>
</ul>
<h3 id="Blocks-的模式"><a href="#Blocks-的模式" class="headerlink" title="Blocks 的模式"></a>Blocks 的模式</h3><h4 id="Block-语法"><a href="#Block-语法" class="headerlink" title="Block 语法"></a>Block 语法</h4><ul>
<li>完整的 Block 语法与一般的 C 语言函数定义相比，仅有两点不同：<strong>没有函数名</strong> 、<strong>带有 ^</strong>;</li>
<li>完整的 Block 语法：<code>^ 返回值类型 参数列表 表达式</code>;</li>
<li>省略返回值类型的 Block 语法：<code>^ 参数列表 表达式</code>;</li>
<li>没有参数类型的 Block 语法：<code>^ 表达式</code>;</li>
</ul>
<p><code>^(int count){return count}</code></p>
<h4 id="Block-类型变量"><a href="#Block-类型变量" class="headerlink" title="Block 类型变量"></a>Block 类型变量</h4><ul>
<li>在 Block 语法下，可以将 Block 语法赋值给声明为 Block 类型的变量中；</li>
<li><code>int (^block)(int)</code> 声明 Block 类型的变量与一般的 C 语言函数指针一样，仅仅是将声明函数指针类型变量的 “*” 变成 “^”；</li>
<li>通过使用 typedef 声明 Block 类型的变量；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef int (^blk_t)(int);</div><div class="line">blk_t blk = ^(int count)&#123;return count+1&#125;;</div></pre></td></tr></table></figure>
<h4 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h4><ul>
<li>Block 定义为：<strong>带有自动变量值的匿名函数</strong>，其中的<strong>带有自动变量值</strong> 在 Block 中表现为 <strong>截获自动变量值</strong>；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">	int day = 256;</div><div class="line">	int val = 10;</div><div class="line">	void (^blk)(void) = ^&#123;printf(val)&#125;;</div><div class="line">	</div><div class="line">	val = 2;</div><div class="line">	blk();	//调用Block</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行结果 val = 10 ，即 Block 表达式截获了自动变量的瞬间值，所以即使在其之后更改了变量的值，也不会影响 Block 执行时自动变量的值；</li>
<li>若想在 Block 语法的表达式中，将值赋给在 Block 语法外声明的自动变量，需要在该自动变量上附加 __block 说明符；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *arr = [NSMutableArray array];</div><div class="line">void (^block)() = ^&#123;</div><div class="line">    [arr addObject:@&quot;1&quot;];//✔️</div><div class="line">    arr = [NSMutableArray array];//❌</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>向数组中添加对象是没问题的，但是重新赋值数组会产生编译错误</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/iOS与OSX 多线程与内存管理第一章：自动引用计数机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/iOS与OSX 多线程与内存管理第一章：自动引用计数机制/" itemprop="url">
                  iOS与OSX 多线程与内存管理第一章：自动引用计数机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T19:25:18+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是自动引用计数"><a href="#什么是自动引用计数" class="headerlink" title="什么是自动引用计数"></a>什么是自动引用计数</h3><ul>
<li>在 Objective-C 中采用 Automatic Reference Counting（ARC）机制，让编译器来进行内存的管理。</li>
</ul>
<h3 id="ARC-的实现"><a href="#ARC-的实现" class="headerlink" title="ARC 的实现"></a>ARC 的实现</h3><h4 id="strong-修饰符"><a href="#strong-修饰符" class="headerlink" title="__strong 修饰符"></a><code>__strong</code> 修饰符</h4><p><code>id __strong obj = [[NSObject alloc] init];</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*编译器的源码模拟*/</div><div class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</div><div class="line">objc_msgSend(obj, @selector(init));</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<h4 id="weak-修饰符"><a href="#weak-修饰符" class="headerlink" title="__weak 修饰符"></a><code>__weak</code> 修饰符</h4><ul>
<li>若附有 <code>__weak</code> 修饰符的变量所引用的对象被废弃，则将 nil 赋值给该变量。</li>
<li>使用附有 <code>__weak</code> 修饰符的变量，即是使用注册到 autoreleasepool 中的对象。</li>
</ul>
<p><code>id __weak obj1 = obj;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*编译器的模拟代码*/</div><div class="line">id obj1;  </div><div class="line">objc_initWeak(&amp;obj1, obj);  </div><div class="line">objc_destoryWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<ul>
<li>weak表和引用计数表类似，都是通过hash表实现的。如果使用weak表，将被释放的对象地址作为key去检索，就能很高效的获取对应的指向该对象的类型为<strong>weak的指针变量的地址。同时很容易理解，一个对象可能有多个</strong>weak指针指向，因此一个对象地址key可能对应多个值。</li>
<li>通过 <code>objc_initWeak</code> 函数初始化附有 __weak 修饰符的变量，在变量作用域结束时通过 <code>objc_destoryWeak</code> 函数释放该变量。</li>
<li>在调用对象的release方法时，会在其中一步调用<code>objc_clear_deallocating</code>函数，该函数会执行以下操作：<ol>
<li>以当前对象的地址作为key，从weak表中获取对应的值—-指向该对象的__weak类型的指针变量；</li>
<li>将取到的所有指针变量的值赋值为nil；</li>
<li>从weak表中删除该key对应的整条记录。</li>
</ol>
</li>
<li>根据以上步骤，前面介绍过的<strong>weak关键字修饰的对象指针所指向的对象被释放时，指针被置为nil就可以实现了。同时由此可知，如果大量使用附有</strong>weak修饰符的变量会消耗响应的CPU资源，因此，应该尽量少使用__weak修饰符。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/EffectiveObjective-C2.0第七章：系统框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/EffectiveObjective-C2.0第七章：系统框架/" itemprop="url">
                  EffectiveObjective-C2.0第七章：系统框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T22:07:29+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一条：多用块枚举，少用-for-循环"><a href="#第一条：多用块枚举，少用-for-循环" class="headerlink" title="第一条：多用块枚举，少用 for 循环"></a>第一条：多用块枚举，少用 for 循环</h3><p>遍历 collection 有四种方式。最基本的办法就是 for 循环，其次是 NSEnumerator 遍历法以及快速遍历法，最新、最先进的是“块枚举法”。</p>
<h4 id="传统的for遍历"><a href="#传统的for遍历" class="headerlink" title="传统的for遍历"></a>传统的for遍历</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">for (int i = 0; i &lt; anArray.count; i++) &#123;</div><div class="line">   id object = anArray[i];</div><div class="line">   // Do something with &apos;object&apos;</div><div class="line">&#125;</div><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">NSArray *keys = [aDictionary allKeys];</div><div class="line">for (int i = 0; i &lt; keys.count; i++) &#123;</div><div class="line">   id key = keys[i];</div><div class="line">   id value = aDictionary[key];</div><div class="line">   // Do something with &apos;key&apos; and &apos;value&apos;</div><div class="line">&#125;</div><div class="line">// Set</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">NSArray *objects = [aSet allObjects];</div><div class="line">for (int i = 0; i &lt; objects.count; i++) &#123;</div><div class="line">   id object = objects[i];</div><div class="line">   // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>我们可以看到，在遍历NSDictionary,和NSet时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。</p>
</blockquote>
<h4 id="利用快速遍历："><a href="#利用快速遍历：" class="headerlink" title="利用快速遍历："></a>利用快速遍历：</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">for (id object in anArray) &#123;</div><div class="line"> // Do something with &apos;object&apos;</div><div class="line">&#125;</div><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">for (id key in aDictionary) &#123;</div><div class="line"> id value = aDictionary[key];</div><div class="line"> // Do something with &apos;key&apos; and &apos;value&apos;</div><div class="line">&#125;</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">for (id object in aSet) &#123;</div><div class="line"> // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。</p>
</blockquote>
<h4 id="使用-Objective-C-1-0-的-NSEnumerator-来遍历"><a href="#使用-Objective-C-1-0-的-NSEnumerator-来遍历" class="headerlink" title="使用 Objective-C 1.0 的 NSEnumerator 来遍历"></a>使用 Objective-C 1.0 的 NSEnumerator 来遍历</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//正向遍历</div><div class="line"> NSArray *anArray = /* ... */;</div><div class="line">   NSEnumerator *enumerator = [anArray objectEnumerator];</div><div class="line">   id object;</div><div class="line">   while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">       // Do something with &apos;object&apos;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //反向遍历</div><div class="line">   NSArray *anArray = /* ... */;</div><div class="line">   NSEnumerator *enumerator = [anArray reverseObjectEnumerator];</div><div class="line">   id object;	</div><div class="line">   while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">       // Do something with &apos;object&apos;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>

&gt; NSEnumerator 是个抽象基类，其中只定义了两个方法，供其具体子类来实现：  
`- (NSArray)allObjects`  
`- (id)nextObject`
</code></pre><h4 id="利用基于块（block）的遍历："><a href="#利用基于块（block）的遍历：" class="headerlink" title="利用基于块（block）的遍历："></a>利用基于块（block）的遍历：</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">[anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)&#123;</div><div class="line">   // Do something with &apos;object&apos;</div><div class="line">   if (shouldStop) &#123;</div><div class="line">      *stop = YES; //使迭代停止</div><div class="line">  &#125;</div><div class="line">&#125;];</div><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop)&#123;</div><div class="line">     // Do something with &apos;key&apos; and &apos;object&apos;</div><div class="line">     if (shouldStop) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">// Set</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">[aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop)&#123;</div><div class="line">     // Do something with &apos;object&apos;</div><div class="line">     if (shouldStop) &#123;</div><div class="line">        *stop = YES;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>我们可以看到，在使用块进行快速枚举的时候，我们可以不创建临时数组。虽然语法上没有快速枚举简洁，但是我们可以获得数组元素对应的序号，字典元素对应的键值，而且，我们还可以随时令遍历终止。<br>利用快速枚举和块的枚举还有一个优点：<strong>能够修改块的方法签名</strong></p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for (NSString *key in aDictionary) &#123;</div><div class="line">        NSString *object = (NSString*)aDictionary[key];</div><div class="line">       // Do something with &apos;key&apos; and &apos;object&apos;</div><div class="line">&#125;	</div><div class="line"></div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">    [aDictionary enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSString *obj, BOOL *stop)&#123;</div><div class="line">             // Do something with &apos;key&apos; and &apos;obj&apos;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>如果我们可以知道集合里的元素类型，就可以修改签名。这样做的好处是：可以让编译期检查该元素是否可以实现我们想调用的方法，如果不能实现，就做另外的处理。这样一来，程序就能变得更加安全。</p>
</blockquote>
<h3 id="第二条：构建缓存时选用-NSCache-而非-NSDictionary"><a href="#第二条：构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="第二条：构建缓存时选用 NSCache 而非 NSDictionary"></a>第二条：构建缓存时选用 NSCache 而非 NSDictionary</h3><h4 id="NSCache-胜过-NSDictionary-之处在于："><a href="#NSCache-胜过-NSDictionary-之处在于：" class="headerlink" title="NSCache 胜过 NSDictionary 之处在于："></a>NSCache 胜过 NSDictionary 之处在于：</h4><ul>
<li>当系统资源将要耗尽时，NScache 可以自动删除缓存，并还会先删除“最久未用”的对象。</li>
<li>NSCache 并不会“拷贝”键，而是会“保留”它，原因在于：很多时候键，都是由不支持拷贝操作的对象来充当的。</li>
<li>NSCache 是线程安全的，开发者在不编写加锁代码的前提下，多个线程可以同时访问 NSCache 对象。</li>
</ul>
<h4 id="开发者可以操控缓存删减其内容的时机，有两个尺度可供调整："><a href="#开发者可以操控缓存删减其内容的时机，有两个尺度可供调整：" class="headerlink" title="开发者可以操控缓存删减其内容的时机，有两个尺度可供调整："></a>开发者可以操控缓存删减其内容的时机，有两个尺度可供调整：</h4><ul>
<li>缓存中的对象总数 （countLimit）</li>
<li>所有对象的总开销值（totalCostLimit）</li>
</ul>
<p>实例用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef void(^EXONetworkFetcherCompletionHandler)(NSData *data);</div><div class="line"></div><div class="line">@interface EXONetworkFetcher : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) NSURL *url;</div><div class="line"></div><div class="line">- (instancetype)initWithURL:(NSURL*)url;</div><div class="line"></div><div class="line">- (void)startWithCompletionHandler:(EXONetworkFetcherCompletionHandler)handler;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass:NSobject ()</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass &#123;</div><div class="line">    NSCache *_cache;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _cache = [[NSCache alloc] init];</div><div class="line">        _cache.countLimit = 100;//对象总数</div><div class="line">        _cache.totalCostLimit = 5*1024*1024;//总开销5MB</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method</div><div class="line"></div><div class="line">- (void)p_downloadForURL:(NSURL*)url &#123;</div><div class="line">    NSData *cacheData = [_cache objectForKey:url];</div><div class="line">    if (cacheData) &#123;</div><div class="line">        [self p_userData:cacheData];</div><div class="line">    &#125;else &#123;</div><div class="line">        EXONetworkFetcher *fetcher = [[EXONetworkFetcher alloc] initWithURL:url];</div><div class="line">        [fetcher startWithCompletionHandler:^(NSData *data) &#123;</div><div class="line">            [_cache setObject:data forKey:url cost:data.length];</div><div class="line">            [self p_userData:data];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_userData:(NSData*)data &#123; &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="NSPurgeableData"><a href="#NSPurgeableData" class="headerlink" title="NSPurgeableData"></a>NSPurgeableData</h4><ul>
<li>NSPurgeableData 此类是 NSMutableData 的子类，而且实现了 NSDiscardableContent 协议。当系统资源紧张时，可以把保存 NSPurgeableData 的那块内存释放掉。</li>
<li>如果访问某个 NSPurgeableData 对象，可以调用其 beginContentAccess 方法，告诉它现在还不能丢弃自己所占据的内存，用完之后，调用 endContentAccess 方法，告诉它在必要的时候可以丢弃自己所占据的内存。</li>
<li>通过 NSCache 的 evictsObjectsWithDiscardedContent 属性，可以开启或关闭此功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass:NSObject ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass &#123;</div><div class="line">    NSCache *_cache;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _cache = [[NSCache alloc] init];</div><div class="line">        _cache.countLimit = 100;//对象总数</div><div class="line">        _cache.totalCostLimit = 5*1024*1024;//总开销</div><div class="line">        _cache.evictsObjectsWithDiscardedContent = YES; //设置开启</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">#pragma mark - Method</div><div class="line"></div><div class="line">- (void)p_downloadForURL:(NSURL*)url &#123;</div><div class="line">    NSPurgeableData *cacheData = [_cache objectForKey:url];</div><div class="line">    if (cacheData) &#123;</div><div class="line">        [cacheData beginContentAccess];</div><div class="line">        [self p_userData:cacheData];</div><div class="line">        [cacheData endContentAccess];</div><div class="line">    &#125;else &#123;</div><div class="line">        EXONetworkFetcher *fetcher = [[EXONetworkFetcher alloc] initWithURL:url];</div><div class="line">        [fetcher startWithCompletionHandler:^(NSData *data) &#123;</div><div class="line">            NSPurgeableData *purgeaData = [NSPurgeableData dataWithData:data];</div><div class="line">            [_cache setObject:purgeaData forKey:url cost:purgeaData.length];</div><div class="line">            [self p_userData:data];</div><div class="line">            [purgeaData endContentAccess];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_userData:(NSData*)data &#123; &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>注：在我们可以直接拿到purgeableData的情况下需要执行beginContentAccess方法。然而，在创建purgeableData的情况下，是不需要执行beginContentAccess，因为在创建了purgeableData之后，其引用计数会自动+1；</p>
</blockquote>
<h3 id="第三条：精简-initialize-与-load-的实现代码"><a href="#第三条：精简-initialize-与-load-的实现代码" class="headerlink" title="第三条：精简 initialize 与 load 的实现代码"></a>第三条：精简 initialize 与 load 的实现代码</h3><h4 id="load-方法"><a href="#load-方法" class="headerlink" title="load 方法"></a>load 方法</h4><p>+(void) load;<br>每个类和分类在加入运行期系统时，都会调用load方法，而且仅仅调用一次。</p>
<h4 id="initialize-方法"><a href="#initialize-方法" class="headerlink" title="initialize 方法"></a>initialize 方法</h4><p>+(void) initialize;<br>这个方法与load方法类似，区别是这个方法会在程序首次调用这个类的时候调用（惰性调用），而且只调用一次（绝对不能主动使用代码调用）。<br>值得注意的一点是，如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zhenyue" />
          <p class="site-author-name" itemprop="name">zhenyue</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhenyue</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
