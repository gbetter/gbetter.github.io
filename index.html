<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="gbetter">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="gbetter">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gbetter">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> gbetter </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">gbetter</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/02/使用Masonry进行autolayout布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/02/使用Masonry进行autolayout布局/" itemprop="url">
                  使用Masonry进行autolayout布局
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-02T09:15:30+08:00">
                2017-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/19/SDWebImage源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/19/SDWebImage源码/" itemprop="url">
                  SDWebImage源码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-19T22:59:05+08:00">
                2017-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="UIImageView-WebCache-h"><a href="#UIImageView-WebCache-h" class="headerlink" title="UIImageView+WebCache.h"></a>UIImageView+WebCache.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">- (void)sd_setImageWithPreviousCachedImageWithURL:(nullable NSURL *)url</div><div class="line">                                 placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                                          options:(SDWebImageOptions)options</div><div class="line">                                         progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                        completed:(nullable SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<blockquote>
<p>上面这些方法统一调用的是下面这个主方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</div><div class="line">          placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<blockquote>
<p>此方法通过调用 <code>UIView+WebCache.h</code> 中的 <code>sd_internalSetImageWithURL：...</code>来实现。</p>
</blockquote>
<h4 id="UIView-WebCache-h"><a href="#UIView-WebCache-h" class="headerlink" title="UIView+WebCache.h"></a>UIView+WebCache.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//返回请求的URL</div><div class="line">- (nullable NSURL *)sd_imageURL;</div><div class="line">//通过 SDWebImageManager 来获取请求的图片，可能在缓存中、可能需要下载</div><div class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</div><div class="line">                  placeholderImage:(nullable UIImage *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(nullable NSString *)operationKey</div><div class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">//取消当前类的Image请求</div><div class="line">- (void)sd_cancelCurrentImageLoad;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageManager-h"><a href="#SDWebImageManager-h" class="headerlink" title="SDWebImageManager.h"></a>SDWebImageManager.h</h4><ul>
<li>SDWebImageManager 通过 <code>sahredManager</code> 单例获取当前对象</li>
<li>并在其初始化方法中获取到 <code>SDImageCache</code> 缓存 和<code>SDWebImageloader</code> 下载 两个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (nonnull instancetype)init &#123;</div><div class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</div><div class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</div><div class="line">    return [self initWithCache:cache downloader:downloader];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _imageCache = cache;</div><div class="line">        _imageDownloader = downloader;</div><div class="line">        _failedURLs = [NSMutableSet new];</div><div class="line">        _runningOperations = [NSMutableArray new];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过下列方法来获取图片： 通过 <code>_imageCache</code> 对象判断缓存中是否存在此图片，若有则返回，若没有则通过 <code>_imageDownloader</code> 对象去服务器下载此图片。         </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</div><div class="line">                                              options:(SDWebImageOptions)options</div><div class="line">                                             progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                            completed:(nullable SDInternalCompletionBlock)completedBlock</div></pre></td></tr></table></figure>
<h4 id="SDImageCache-h"><a href="#SDImageCache-h" class="headerlink" title="SDImageCache.h"></a>SDImageCache.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//获取当前对象</div><div class="line">+ (nonnull instancetype)sharedImageCache;</div><div class="line"></div><div class="line">//通过 key 在缓存中查找对应的图片</div><div class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock;</div></pre></td></tr></table></figure>
<h4 id="SDWebImageDownloader-h"><a href="#SDWebImageDownloader-h" class="headerlink" title="SDWebImageDownloader.h"></a>SDWebImageDownloader.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//获取当前SDWebImageDownloader对象</div><div class="line">+ (nonnull instancetype)sharedDownloader</div><div class="line"></div><div class="line">//通过此方法从服务器下载图片</div><div class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock</div></pre></td></tr></table></figure>
<h4 id="SDWebImageDownloaderOperation-h"><a href="#SDWebImageDownloaderOperation-h" class="headerlink" title="SDWebImageDownloaderOperation.h"></a>SDWebImageDownloaderOperation.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//初始化一个 SDWebImageDownloaderOperation 对象</div><div class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</div><div class="line">                              inSession:(nullable NSURLSession *)session</div><div class="line">                                options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">//添加 下载进度和下载完成的 block 回调</div><div class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</div><div class="line"></div><div class="line">// 通过 token 取消当前下载</div><div class="line">- (BOOL)cancel:(nullable id)token;</div></pre></td></tr></table></figure>
<h4 id="UIView-WebCacheOperation-h"><a href="#UIView-WebCacheOperation-h" class="headerlink" title="UIView+WebCacheOperation.h"></a>UIView+WebCacheOperation.h</h4><ul>
<li>本类主要用于 operation 对象的管理,当一个对象（UIImageView）被重复请求时，将会把第一次的 operation cancel 掉，将新的 operation 加入到 operationDictionary 字典中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//获取 NSMutableDictionary 类型的 operationDictionary</div><div class="line">- (SDOperationsDictionary *)operationDictionary;</div><div class="line"></div><div class="line">//通过 key 值将 operation 对象存入 operationDictionary 字典中</div><div class="line">- (void)sd_setImageLoadOperation:(nullable id)operation forKey:(nullable NSString *)key;</div><div class="line"></div><div class="line">//通过 key 标识 取消operation请求</div><div class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key;</div><div class="line"></div><div class="line">//通过 key 标识 将 operation 对象从operationDictionary字典中删除</div><div class="line">- (void)sd_removeImageLoadOperationWithKey:(nullable NSString *)key;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/17/iOS 并发编程之 Operation Queues /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/iOS 并发编程之 Operation Queues /" itemprop="url">
                  iOS并发编程之OperationQueues
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T10:14:05+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li>进程（process）：指的是一个正在运行中的可执行文件，每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程。另外，当一个进程的主线程退出时，这个进程就结束了。</li>
<li>线程（thread）：指的是一个独立的代码执行路径。</li>
<li>任务（task）：指的是我们需要执行的工作，是一个抽象的概念，用通俗点的话说，就是一段代码。</li>
</ul>
<h4 id="串行-VS-并发"><a href="#串行-VS-并发" class="headerlink" title="串行 VS 并发"></a>串行 VS 并发</h4><p>从本质上来讲，串行和并发的主要区别在于允许同时执行的任务数量，串行，指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；并发，指的是允许多个任务同时执行。</p>
<h4 id="同步-VS-异步"><a href="#同步-VS-异步" class="headerlink" title="同步 VS 异步"></a>同步 VS 异步</h4><p>同步和异步操作的主要区别在于是否等待操作的完成，亦即是否阻塞当前线程。同步操作会等待操作执行完成后继续执行接下来的代码，而异步操作则恰好相反，它会在调用后立即返回，不会等待操作的执行结果。</p>
<h4 id="队列-VS-线程"><a href="#队列-VS-线程" class="headerlink" title="队列 VS 线程"></a>队列 VS 线程</h4><p>在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。</p>
<h3 id="iOS-的并发编程模型"><a href="#iOS-的并发编程模型" class="headerlink" title="iOS 的并发编程模型"></a>iOS 的并发编程模型</h3><h4 id="Operation-Queues-VS-GCD"><a href="#Operation-Queues-VS-GCD" class="headerlink" title="Operation Queues VS GCD"></a>Operation Queues VS GCD</h4><p>CGD 是苹果基于 C 语言开发的，一个用于多核编程的解决方案，主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。而 Operation Queues 则是一个建立在 GCD 基础之上的，面向对象的解决方案，它使用起来比 GCD 更加灵活，功能更强大。</p>
<ul>
<li>Operation Queues：相对 GCD 来说，使用 Operation Queues 会增加一点点额外的开销，但是我们却换来了非常强大的灵活性和功能，我们可以给 operation 添加依赖关系、取消一个正在执行的 Operation 、暂停和恢复 Operation queue等</li>
<li>GCD ：则是一种更轻量级的，以 FIFO 的顺序执行并发任务的方式，使用 GCD 时我们并不关心任务的调度情况，而让系统帮我们自动处理。但是 GCD 的短板也是非常明显的，比如我们想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得非常棘手。</li>
</ul>
<h3 id="关于-Operation-对象"><a href="#关于-Operation-对象" class="headerlink" title="关于 Operation 对象"></a>关于 Operation 对象</h3><p>NSOperation 本身是一个抽象类，不能直接实例化，因此如果我们想要使用它来执行具体的任务的话，就必须创建子类或者使用系统预定义的两个子类，NSInvocationOperation 和 NSBlockOperation。</p>
<h4 id="Operation-支持的特性"><a href="#Operation-支持的特性" class="headerlink" title="Operation 支持的特性"></a>Operation 支持的特性</h4><ul>
<li>支持在 Operation 之间建立依赖关系，只有当一个 Operation 所依赖的所有的 Operation 都执行完成时，这个 Operation 才能开始执行;</li>
<li>支持一个可选的 completion block ，这个 block 将会在 Operation 的主任务执行完成时被调用。</li>
<li>支持通过 kvo 来观察 Operation 执行的状态变化。</li>
<li>支持设置执行的优先级，从而影响 Operation 之间的相对执行顺序。</li>
<li>支持取消操作，可以允许我们停止正在执行的 Operation。</li>
</ul>
<h4 id="创建-NSInvocationOperation-和-NSBlockOperation"><a href="#创建-NSInvocationOperation-和-NSBlockOperation" class="headerlink" title="创建 NSInvocationOperation 和 NSBlockOperation"></a>创建 NSInvocationOperation 和 NSBlockOperation</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (NSInvocationOperation *) invocationOperationWithData:(id)data &#123;</div><div class="line">    return [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(p_myRaskMethod:) object:data];</div><div class="line">&#125;</div><div class="line">- (NSBlockOperation*) blockOperationWithData:(id)data &#123;</div><div class="line">    NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">        NSLog(@&quot;Finsh executing block1&quot;);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [blockOperation addExecutionBlock:^&#123;</div><div class="line">         NSLog(@&quot;Finsh executing block2&quot;);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [blockOperation addExecutionBlock:^&#123;</div><div class="line">         NSLog(@&quot;Finsh executing block3&quot;);</div><div class="line">    &#125;];</div><div class="line">    return blockOperation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method</div><div class="line">- (void)p_myRaskMethod:(id)data &#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="自定义-Operation-对象"><a href="#自定义-Operation-对象" class="headerlink" title="自定义 Operation 对象"></a>自定义 Operation 对象</h4><p>每一个 Operation 至少需要实现两个方法：</p>
<ul>
<li>一个自定义的初始化方法</li>
<li>main 方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@implementation EXOChildOperation</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123; &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)main &#123;</div><div class="line">    @try &#123;</div><div class="line">        if (self.isCancelled) return;</div><div class="line">        //要执行的任务</div><div class="line">        NSLog(@&quot;任务==Start-%@-%@&quot;,[NSThread currentThread],[NSThread mainThread]);</div><div class="line">        for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">            if (self.isCancelled) return;</div><div class="line">            sleep(2);   //模拟任务</div><div class="line">        &#125;</div><div class="line">        NSLog(@&quot;任务==完成&quot;);</div><div class="line">    &#125; @catch (NSException *exception) &#123;</div><div class="line">        NSLog(@&quot;%s%@&quot;,__func__,exception);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">``` </div><div class="line">&gt; 要相应 cancel 事件，需要在代码中定期检查 `isCanceled` 方法的返回值</div><div class="line"></div><div class="line">#### 配置并发执行的 Operation</div><div class="line">默认情况下，Operation 是同步执行的，在调用 `start` 方法的线程中执行他们的任务，如果 Operation 和 Operation queue 结合使用，operation queue 可以为**非并发**Operation 提供线程，因此 大部分的 Operation 仍然可以异步执行。</div><div class="line"></div><div class="line">需要重写的方法：</div><div class="line">- `start` 必须重写，特别注意不要在我们重写的 `start` 方法中调用父类的实现。</div><div class="line">- `main`	可选的，通常这个方法就是专门用来实现与该 operation 相关联的任务的。</div><div class="line">- `isExecuting`和`isFinished` 必须的， 此外，当这两个方法所代表的值发生变化时，我们需要生成相应的 KVO 通知，以便外界能够观察到这些状态的变化</div><div class="line">- `isAsynchronous` 必须的，这个方法的返回值用来标识一个 operation 是否是并发的 operation ，我们需要重写这个方法并返回 YES 。</div></pre></td></tr></table></figure>
<p>//  配置 并发 的 Operation</p>
<p>#import “EXOParallelOperation.h”</p>
<p>@interface EXOParallelOperation (){<br>    BOOL executing; //是否执行中<br>    BOOL finished;  //是否完成<br>}</p>
<p>@end</p>
<p>@implementation EXOParallelOperation</p>
<ul>
<li><p>(instancetype)init<br>{<br>  self = [super init];<br>  if (self) {</p>
<pre><code>executing = NO;
finished  = NO;
</code></pre><p>  }<br>  return self;<br>}</p>
</li>
<li><p>(void)start {<br>  if ([self isCancelled]) {</p>
<pre><code>[self willChangeValueForKey:@&quot;isFinished&quot;];
finished = YES;
[self didChangeValueForKey:@&quot;isFinished&quot;];
return;
</code></pre><p>  }</p>
<p>  [self willChangeValueForKey:@”isExecuting”];<br>  [NSThread detachNewThreadWithBlock:^{</p>
<pre><code>[self main];
</code></pre><p>  }];<br>  executing = YES;<br>  [self didChangeValueForKey:@”isExecuting”];<br>}</p>
</li>
<li><p>(BOOL)isExecuting {<br>  return executing;<br>}</p>
</li>
<li><p>(BOOL)isFinished {<br>  return finished;<br>}</p>
</li>
</ul>
<p>/**<br> 是否并发执行</p>
<p> @return Y 并发 N 非并发<br> */</p>
<ul>
<li><p>(BOOL)isAsynchronous {<br>  return YES;<br>}</p>
</li>
<li><p>(void)main {<br>  @try {</p>
<pre><code>@autoreleasepool {
    BOOL taskIsFinished = NO;
    while (!taskIsFinished &amp;&amp; ![self isCancelled]) {
        //自定义 操作
        sleep(2);
        taskIsFinished = YES;
        NSLog(@&quot;currentThread = %@, main = %@&quot;,[NSThread currentThread],[NSThread mainThread]);
    }
    [self completeOperation];

}
</code></pre><p>  } @catch (NSException *exception) {</p>
<p>  }<br>}</p>
</li>
<li><p>(void)completeOperation {<br>  [self willChangeValueForKey:@”isFinished”];<br>  [self willChangeValueForKey:@”isExecuting”];</p>
<p>  executing = NO;<br>  finished = YES;</p>
<p>  [self didChangeValueForKey:@”isExecuting”];<br>  [self didChangeValueForKey:@”isFinished”];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; 注意，有一个非常重要的点需要引起我们的注意，那就是即使一个 operation 是被 cancel 掉了，我们仍然需要手动触发 isFinished 的 KVO 通知。因为当一个 operation 依赖其他 operation 时，它会观察所有其他 operation 的 isFinished 的值的变化，只有当它依赖的所有 operation 的 isFinished 的值为 YES 时，这个 operation 才能够开始执行。因此，如果一个我们自定义的 operation 被取消了但却没有手动触发 isFinished 的 KVO 通知的话，那么所有依赖它的 operation 都不会执行。</div><div class="line"></div><div class="line">### 定制 Operation 对象的执行行为</div><div class="line"></div><div class="line">#### 配置依赖关系</div><div class="line">通过配置依赖关系，我们可以让不同的 Operation 串行执行，一个 operation 只有在它依赖的所有 operation 都执行完成后才能开始执行。</div></pre></td></tr></table></figure>
</li>
<li><p>(void)addDependency:(NSOperation *)op;</p>
</li>
<li>(void)removeDependency:(NSOperation *)op;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 就是不要在 operation 之间添加循环依赖，因为这样会导致这些 operation 都不会被执行。</div><div class="line">&gt; 我们应该在手动执行一个 operation 或将它添加到 operation queue 前配置好依赖关系，因为在之后添加的依赖关系可能会失效。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>NSOperationQueue <em>operationQueue = [[NSOperationQueue alloc] init];<br>[operationQueue setMaxConcurrentOperationCount:2];  //设置最大并发数<br>EXOParallelOperation </em>operation = [[EXOParallelOperation alloc] init];<br>EXOChildOperation *operation2 = [[EXOChildOperation alloc] init];<br>//添加到 operation queue 前配置好依赖关系 operation2 依赖于 operation<br>[operation2 addDependency:operation];<br>[operationQueue addOperation:operation];<br>[operationQueue addOperation:operation2];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#### 修改Operation 在队列中的优先级</div><div class="line">对于添加到 Operation queue 中的 Operation 来说，决定它们执行顺序的第一要素是它们的 `isReady` 状态，其次是它们在队列中的优先级，Operation 的 `isReady` 状态取决于它们的依赖关系，而都在队列中的优先级则是 Operation 本身的属性。默认新创建的 Operation 的优先级都为 `normal` 的,**但是我们可以通过 `setQueuePriority:` 方法来提高或降低 Operation 在队列中的优先级**。</div><div class="line"></div><div class="line">需要注意的是：**队列的优先级只应用在相同的 Operation queue 中的 Operation 之间，不同的 Operation queue 不受此影响**。</div><div class="line"></div><div class="line">#### 修改 Operation 执行任务线程的优先级</div><div class="line"></div><div class="line">* 从 iOS4.0 开始，我们可以修改 operation 的执行任务线程的优先级，我们可以给 Operation 的线程指定一个从 `0.0` 到 `1.0` 的浮点数值，`0.0` 表示最低的优先级，`1.0` 表示最高的优先级，默认值为 `0.5` 。</div><div class="line">* 注意：**我们只能够在执行一个 Operation 或将其添加到 Operation queue 前，通过 Operation 的 `setThreadPriority:` 方法来修改它的线程优先级**。另外，我们指定的这个线程优先级只会影响 main 方法执行时所在线程的优先级。*所有其它的代码，包括 operation 的 completion block 所在的线程会一直以默认的线程优先级执行*。**因此，当我们自定义一个并发的 operation 类时，我们也需要在 start 方法中根据指定的值自行修改线程的优先级**</div><div class="line"></div><div class="line">#### 设置 Completion Block</div><div class="line">1. 一个 Operation 可以在它的主任务执行完成时回调一个 completion block。直接调用 Operation 的 `setCompletionBlock：` 方法即可。</div><div class="line">2. 注意，当一个 Operation 被取消时，它的 completion block 仍然会被调用，**所以我们需要在真正执行代码前检查一下 isCancelled 方法的返回值，如果有必要的话我们可以在 completion block 中使用 GCD 来保证从主线程更新 UI** </div><div class="line"></div><div class="line">### 执行 Operation 对象</div><div class="line">* 将 operation 添加到 Operation queue 中，让 Operation queue 来帮助我们自动执行；</div><div class="line">* 直接调用 `start` 方法手动执行 Operation；</div><div class="line"></div><div class="line">#### 添加 Operation 到 Operation queue 中</div><div class="line">`NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];`</div><div class="line"></div><div class="line">创建好 Operation queue 后，我们有三种方法添加 Operation 到 Operation queue 中：</div><div class="line"></div><div class="line">* `addOperation:` 添加一个 Operation 到 Operation queue 中；</div><div class="line">* `addOperation: waitUntilFinished:` 添加一组 Operation 到 Operation queue 中；</div><div class="line">* `addOperationWithBlock:` 直接添加一个 block 到 Operation queue 中，而不用创建一个 `NSBlockOperation` 对象；</div><div class="line"></div><div class="line">在大多数情况下，一个 operation 被添加到 operation queue 后不久就会执行，但是也有很多原因会使 operation queue 延迟执行入队的 operation 。比如，我们前面提到了的，如果一个 operation 所依赖的其他 operation 还没有执行完成时，这个 operation 就不能开始执行；再比如说 operation queue 被暂停执行或者已经达到了它最大可并发的 operation 数。下面的示例代码展示了这三种方法的基本用法：</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)executeOperationUsingOperationQueue {<br>  NSOperationQueue *operationQueue = [[NSOperationQueue alloc] init];</p>
<p>  NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(taskMethod) object:nil];<br>  [operationQueue addOperation:invocationOperation];</p>
<p>  NSBlockOperation *blockOperation1 = [NSBlockOperation blockOperationWithBlock:^{</p>
<pre><code>NSLog(@&quot;Start executing blockOperation1, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);
sleep(3);
NSLog(@&quot;Finish executing blockOperation1&quot;);
</code></pre><p>  }];</p>
<p>  NSBlockOperation *blockOperation2 = [NSBlockOperation blockOperationWithBlock:^{</p>
<pre><code>NSLog(@&quot;Start executing blockOperation2, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);
sleep(3);
NSLog(@&quot;Finish executing blockOperation2&quot;);
</code></pre><p>  }];</p>
<p>  [operationQueue addOperations:@[ blockOperation1, blockOperation2 ] waitUntilFinished:NO];</p>
<p>  [operationQueue addOperationWithBlock:^{</p>
<pre><code>NSLog(@&quot;Start executing block, mainThread: %@, currentThread: %@&quot;, [NSThread mainThread], [NSThread currentThread]);
sleep(3);
NSLog(@&quot;Finish executing block&quot;);
</code></pre><p>  }];</p>
<p>  [operationQueue waitUntilAllOperationsAreFinished];<br>}<br>``` </p>
</li>
</ul>
<ul>
<li>尽管 NSOperationQueue 类被设计成用来并发执行 operation 的，但是我们可以强制一个 operation queue 一次只执行一个 operation 。我们可以通过 <code>setMaxConcurrentOperationCount:</code> 方法来设置一个 operation queue 的最大并发的 operation 数。将值设置成 1 就可以实现让 operation queue 一次只执行一个 operation 的目的。</li>
<li>operation 的执行顺序还是会受到其他因素的影响，比如 operation 的 <code>isReady</code> 状态、operation 的队列优先级等。 </li>
<li>因此，一个穿行的 operation queue 与一个串行的 dispatch queue 还是有本质区别的，因为 dispatch queue 的执行顺序一直是 <code>FIFO</code> 的。如果 operation 的执行顺序对我们来说很重要，那么我们就应该在将 operation 添加到 operation queue 之前，就建立好它的依赖关系。</li>
</ul>
<h4 id="取消-Operation"><a href="#取消-Operation" class="headerlink" title="取消 Operation"></a>取消 Operation</h4><ul>
<li>当一个 operation 被添加到 operation queue 中后，这个 operation 的所有权就属于这个 operation queue 了，并且不能被移除。</li>
<li>唯一从 operation queue 中出队一个 operation 的方式就是调用它的 <code>cancel</code> 方法取消这个 operation ，或者调用 operation queue 的 <code>cancelAllOperations</code> 方法取消这个 Operation queue 中全部的 Operation。</li>
<li>当一个 Operation 被取消后，这个 Operation 的 <code>isFinished</code> 状态也会变成 <code>YES</code>，这样做的好处是所有依赖它的 Operation 能接收到这个 <code>KVO</code> 通知，从而能够清除这个依赖关系。</li>
</ul>
<h4 id="等待-Operation-执行完成"><a href="#等待-Operation-执行完成" class="headerlink" title="等待 Operation 执行完成"></a>等待 Operation 执行完成</h4><ul>
<li>我们可以调用 NSOperation 类的 <code>waitUntilFinished</code> 方法来阻塞当前线程，直到这个 Operation 执行完成。</li>
<li>除了等待一个单独的 operation 执行完成外，我们也可以通过调用 NSOperationQueue 的<code>waitUntilAlloperationsAreFinished</code> 方法来等待 operation queue 中的所有 operation 执行完成。</li>
<li>当我们在等待一个 operation queue 中的所有 operation 执行完成时，其他的线程仍然可以向这个 operation queue 中添加 operation ，从而延长我们的等待时间。</li>
</ul>
<h4 id="暂停和恢复-Operation-Queue"><a href="#暂停和恢复-Operation-Queue" class="headerlink" title="暂停和恢复 Operation Queue"></a>暂停和恢复 Operation Queue</h4><ul>
<li>我们可以通过 Operation queue 的 <code>setSuspended:</code> 方法实现队列的暂停和恢复。</li>
<li>暂停执行 operation queue <strong>并不能使正在执行的 operation 暂停执行，而只是简单地暂停调度新的 operation</strong>。</li>
<li><strong>不能单独暂停执行一个 operation，除非直接 <code>cancel</code> 掉</strong>。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/iOS与OSX 多线程与内存管理第三章：GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/iOS与OSX 多线程与内存管理第三章：GCD/" itemprop="url">
                  iOS与OSX 多线程与内存管理第三章：GCD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T19:27:03+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h3><ul>
<li>Dispatch Queue 按照追加的顺序（先进先出 FIFO，First-In-First-Out）执行处理。在执行处理时存在两种 Dispatch Queue，<strong>一种是等待现在执行中处理的 Serial Dispatch Queue，另一种是不等待现在执行中处理的 Concurrent Dispatch Queue</strong>。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建串行队列</div><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.zzy.gcd.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">//创建并发队列</div><div class="line">dispatch_queue_t concurrenyQueue = dispatch_queue_create(&quot;com.zzy.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<ul>
<li>当多线程更新相同资源导致数据竞争时使用 Serial Dispatch Queue 。</li>
<li>Main Dispatch Queue 是在主线程中执行的 Dispatch Queue，因为主线程只有一个，所以 Main Dispatch Queue 自然就是 Serial Dispatch Queue。</li>
<li>Global Dispatch Queue 是所有的应用程序都能够使用的 Concurrent Dispatch Queue。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Main Dispatch Queue 的获取方法</div><div class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">//Global Dispatch Queue 的获取方法</div><div class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>
<ul>
<li>使用 <code>dispatch_set_target_queue</code> 更改 Dispatch Queue 的执行优先级 <a href="http://www.cnblogs.com/denz/archive/2016/02/24/5214297.html" target="_blank" rel="external">用法</a></li>
</ul>
<h3 id="Dispatch-after"><a href="#Dispatch-after" class="headerlink" title="Dispatch_after"></a>Dispatch_after</h3><ul>
<li>dispatch_after 并不是在指定的时间后执行处理，而只是在指定的时间追加处理到 Dispatch Queue。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</div><div class="line">    dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;1 sec 将其添加到main队列&quot;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p><code>DISPATCH_TIME_NOW</code> 表示现在的时间、<code>NSEC_PER_SEC</code>和秒为乘积、<code>NSEC_PER_MSEC</code>和毫秒为乘积。</p>
</blockquote>
<h3 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h3><ul>
<li>在追加到 Dispatch Queue 中的多个处理全部结束后想执行结束处理，第一种方式 使用 Serial Dispatch Queue ，将想要执行的处理全部追加到该 Serial Dispatch Queue 中并在最后追加结束处理，即可实现。 第二种方式 <strong>在使用 Concurrent Dispatch Queue 时或同时使用多个 Dispatch Queue 时，使用 Dispatch Group</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    NSLog(@&quot;block0&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    NSLog(@&quot;block1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;done&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>另外，在 Dispatch Group 中也可以使用 <code>dispatch_group_wait</code> 函数仅等待全部处理执行结束。</li>
</ul>
<p><code>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</code></p>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a><code>dispatch_barrier_async</code></h3><ul>
<li>在访问数据库或者文件的时候，写入操作不可与其它写入操作并行执行，但读取处理只是与读取处理并行执行，是没有问题的。</li>
<li><code>dispatch_barrier_async</code> 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束后，再将指定的处理追加到该 Concurrent Dispatch Queue 中，在其执行完成之后，Concurrent Dispatch Queue 才又开始处理后续的并行执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_async(queue, blk0_for_reading);</div><div class="line">dispatch_async(queue, blk1_for_reading);</div><div class="line">dispatch_async(queue, blk2_for_reading);</div><div class="line">dispatch_async(queue, blk3_for_reading);</div><div class="line">dispatch_barrier_async(queue, blk_for_writing);</div><div class="line">dispatch_async(queue, blk4_for_reading);</div><div class="line">dispatch_async(queue, blk5_for_reading);</div><div class="line">dispatch_async(queue, blk6_for_reading);</div></pre></td></tr></table></figure>
<ul>
<li><code>dispatch_barrier_async</code>和<code>dispatch_barrier_sync</code>的区别在于是否等待当前任务执行完成后再将后续的任务添加到 Dispatch Queue 中。</li>
</ul>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a><code>dispatch_apply</code></h3><ul>
<li>该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_apply(5, queue, ^(size_t index) &#123;</div><div class="line">    NSLog(@&quot;index = %li&quot;,index);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;done&quot;);</div></pre></td></tr></table></figure>
<blockquote>
<p>该源代码的执行结果：（各个处理的时常不一定，但done必定在最后的位置上）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">2</div><div class="line">3</div><div class="line">1</div><div class="line">4</div><div class="line">done</div></pre></td></tr></table></figure>
<ul>
<li>另外，由于 <code>dispatch_apply</code> 函数也与 <code>dispatch_sync</code> 函数相同，会等待处理执行结束，<strong>因此推荐在 <code>dispatch_async</code>函数中非同步的执行 <code>dispatch_apply</code> 函数</strong>。</li>
</ul>
<h3 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a><code>dispatch_suspend / dispatch_resume</code></h3><ul>
<li>当追加大量处理到 Dispatch Queue 时，在追加处理的过程中，有时希望不执行已追加的处理。例如演算结果被 Block 截获时，一些处理会对这个演算结果造成影响。</li>
<li><code>dispatch_suspend</code> 函数挂起指定的 Dispatch Queue <code>dispatch_suspend(queue);</code></li>
<li><code>dispatch_resume</code> 函数恢复指定的 Dispatch Queue <code>dispatch_resume(queue);</code></li>
<li>这些函数对已经执行的函数没有影响。挂起后，追加到队列中但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</li>
</ul>
<h3 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h3><ul>
<li>当并行执行的处理更新数据时，会产生数据不一致的情况，有时程序还会异常结束。虽然使用 Serial Dispatch Queue 和 <code>dispatch_barrier_async</code> 函数可以避免这类问题，但有必要进行耕细粒度的排他控制。</li>
<li>Dispatch Semaphore 是持有计数的信号，当计数为 0 时等待，计数为 1 或大于 1 时，减去 1 而不等待。</li>
<li>主要有三个函数：<ol>
<li>初始化信号量：  <code>dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</code></li>
<li>当信号量计数为 1 或大于 1 时，减去 1 而不等待，否则等待：   <code>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</code></li>
<li>将 Dispatch Semaphore 的计数 +1：  <code>dispatch_semaphore_signal(semaphore);</code></li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">/*</div><div class="line"> *  生成 Dispatch Semaphore</div><div class="line"> *</div><div class="line"> *  Dispatch Semaphore 的计数初始值设定为 “1” 以保证可访问 NSMutableArray 类 对象的线程同时只能有一个。</div><div class="line"> */</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</div><div class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">for (int i = 0; i &lt; 10000; i++) &#123;</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        /*</div><div class="line">         *  等待 Dispatch Semaphore</div><div class="line">         *  一直等待直到 Dispatch Semaphore 的计数值达到大于等于 1</div><div class="line">         */</div><div class="line">        </div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">        </div><div class="line">        /*</div><div class="line">         *  由于 Dispatch Semaphore 的计数值大于等于 1</div><div class="line">         *  dispatch_semaphore_wait 使计数值减去 1 </div><div class="line">         *</div><div class="line">         *  执行到此时 Dispatch Semaphore 的计数恒为 “0”  </div><div class="line">         *  由于可访问 NSMutableArray 类对象的线程数只有1个，因此可安全的进行更新。</div><div class="line">         */</div><div class="line">        </div><div class="line">        [array addObject:[NSNumber numberWithInt:i]];</div><div class="line">        </div><div class="line">        /*</div><div class="line">         *  排他控制处理结束</div><div class="line">         *  通过 dispatch_semaphore_signal 函数将 Dispatch Semaphore 的计数 +1</div><div class="line">         *</div><div class="line">         **/</div><div class="line">        </div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a><code>dispatch_once</code></h3><ul>
<li><code>dispatch_once</code> 函数是保证在应用程序执行中只执行一次指定处理的 API。使用dispatch_once 可以简化代码并且彻底保证线程安全，开发者无需担心加锁或同步，而且执行效率更高。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+(instancetype)sharedInstance&#123;   </div><div class="line">    static Singleton *sharedSingleton = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        sharedSingleton = [[Singleton alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return  sharedSingleton;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (instancetype)sharedInstance &#123;</div><div class="line">    static ViewController *controller = nil;</div><div class="line">    @synchronized (self) &#123;</div><div class="line">        if (!controller) &#123;</div><div class="line">            controller = [ViewController new];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return controller;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h3><ul>
<li>在读取较大文件时，如果将文件分成合适的大小并使用Global Dispatch Queue并列读取的话，应该会比一般的读取速度快不少。现今的输入/输出硬件已经可以做到一次使用多个线程更快地并列读取了。能实现这一功能的就是Dispatch I/O和Dispatch Data。<br>通过Dispatch I/O读写文件时，使用Global Dispatch Queue将一个文件按大小read/write。</li>
</ul>
<h3 id="Dispatch-Source-定时器"><a href="#Dispatch-Source-定时器" class="headerlink" title="Dispatch Source (定时器)"></a>Dispatch Source (定时器)</h3><ul>
<li>NSTimer受runloop的影响，由于runloop需要处理很多任务，导致NSTimer的精度降低，在日常开发中，如果我们需要对定时器的精度要求很高的话，可以考虑dispatch_source_t去实现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">//设置开始时间 2s 后，时间间隔 1s</div><div class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);</div><div class="line">dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line">    NSLog(@&quot;----self.timer---&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_resume(timer);</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/iOS与OSX 多线程与内存管理第二章：Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/iOS与OSX 多线程与内存管理第二章：Block/" itemprop="url">
                  iOS与OSX 多线程与内存管理第二章：Block
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T19:26:14+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Blocks-概要"><a href="#Blocks-概要" class="headerlink" title="Blocks 概要"></a>Blocks 概要</h3><ul>
<li>Blocks 是 C 语言的扩展功能，其定义为：<strong>带有自动变量（局部变量）的匿名函数</strong>。</li>
</ul>
<h3 id="Blocks-的模式"><a href="#Blocks-的模式" class="headerlink" title="Blocks 的模式"></a>Blocks 的模式</h3><h4 id="Block-语法"><a href="#Block-语法" class="headerlink" title="Block 语法"></a>Block 语法</h4><ul>
<li>完整的 Block 语法与一般的 C 语言函数定义相比，仅有两点不同：<strong>没有函数名</strong> 、<strong>带有 ^</strong>;</li>
<li>完整的 Block 语法：<code>^ 返回值类型 参数列表 表达式</code>;</li>
<li>省略返回值类型的 Block 语法：<code>^ 参数列表 表达式</code>;</li>
<li>没有参数类型的 Block 语法：<code>^ 表达式</code>;</li>
</ul>
<p><code>^(int count){return count}</code></p>
<h4 id="Block-类型变量"><a href="#Block-类型变量" class="headerlink" title="Block 类型变量"></a>Block 类型变量</h4><ul>
<li>在 Block 语法下，可以将 Block 语法赋值给声明为 Block 类型的变量中；</li>
<li><code>int (^block)(int)</code> 声明 Block 类型的变量与一般的 C 语言函数指针一样，仅仅是将声明函数指针类型变量的 “*” 变成 “^”；</li>
<li>通过使用 typedef 声明 Block 类型的变量；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef int (^blk_t)(int);</div><div class="line">blk_t blk = ^(int count)&#123;return count+1&#125;;</div></pre></td></tr></table></figure>
<h4 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h4><ul>
<li>Block 定义为：<strong>带有自动变量值的匿名函数</strong>，其中的<strong>带有自动变量值</strong> 在 Block 中表现为 <strong>截获自动变量值</strong>；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">	int day = 256;</div><div class="line">	int val = 10;</div><div class="line">	void (^blk)(void) = ^&#123;printf(val)&#125;;</div><div class="line">	</div><div class="line">	val = 2;</div><div class="line">	blk();	//调用Block</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行结果 val = 10 ，即 Block 表达式截获了自动变量的瞬间值，所以即使在其之后更改了变量的值，也不会影响 Block 执行时自动变量的值；</li>
<li>若想在 Block 语法的表达式中，将值赋给在 Block 语法外声明的自动变量，需要在该自动变量上附加 __block 说明符；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *arr = [NSMutableArray array];</div><div class="line">void (^block)() = ^&#123;</div><div class="line">    [arr addObject:@&quot;1&quot;];//✔️</div><div class="line">    arr = [NSMutableArray array];//❌</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>向数组中添加对象是没问题的，但是重新赋值数组会产生编译错误</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/iOS与OSX 多线程与内存管理第一章：自动引用计数机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/iOS与OSX 多线程与内存管理第一章：自动引用计数机制/" itemprop="url">
                  iOS与OSX 多线程与内存管理第一章：自动引用计数机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T19:25:18+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是自动引用计数"><a href="#什么是自动引用计数" class="headerlink" title="什么是自动引用计数"></a>什么是自动引用计数</h3><ul>
<li>在 Objective-C 中采用 Automatic Reference Counting（ARC）机制，让编译器来进行内存的管理。</li>
</ul>
<h3 id="ARC-的实现"><a href="#ARC-的实现" class="headerlink" title="ARC 的实现"></a>ARC 的实现</h3><h4 id="strong-修饰符"><a href="#strong-修饰符" class="headerlink" title="__strong 修饰符"></a><code>__strong</code> 修饰符</h4><p><code>id __strong obj = [[NSObject alloc] init];</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*编译器的源码模拟*/</div><div class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</div><div class="line">objc_msgSend(obj, @selector(init));</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<h4 id="weak-修饰符"><a href="#weak-修饰符" class="headerlink" title="__weak 修饰符"></a><code>__weak</code> 修饰符</h4><ul>
<li>若附有 <code>__weak</code> 修饰符的变量所引用的对象被废弃，则将 nil 赋值给该变量。</li>
<li>使用附有 <code>__weak</code> 修饰符的变量，即是使用注册到 autoreleasepool 中的对象。</li>
</ul>
<p><code>id __weak obj1 = obj;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*编译器的模拟代码*/</div><div class="line">id obj1;  </div><div class="line">objc_initWeak(&amp;obj1, obj);  </div><div class="line">objc_destoryWeak(&amp;obj1);</div></pre></td></tr></table></figure>
<ul>
<li>weak表和引用计数表类似，都是通过hash表实现的。如果使用weak表，将被释放的对象地址作为key去检索，就能很高效的获取对应的指向该对象的类型为<strong>weak的指针变量的地址。同时很容易理解，一个对象可能有多个</strong>weak指针指向，因此一个对象地址key可能对应多个值。</li>
<li>通过 <code>objc_initWeak</code> 函数初始化附有 __weak 修饰符的变量，在变量作用域结束时通过 <code>objc_destoryWeak</code> 函数释放该变量。</li>
<li>在调用对象的release方法时，会在其中一步调用<code>objc_clear_deallocating</code>函数，该函数会执行以下操作：<ol>
<li>以当前对象的地址作为key，从weak表中获取对应的值—-指向该对象的__weak类型的指针变量；</li>
<li>将取到的所有指针变量的值赋值为nil；</li>
<li>从weak表中删除该key对应的整条记录。</li>
</ol>
</li>
<li>根据以上步骤，前面介绍过的<strong>weak关键字修饰的对象指针所指向的对象被释放时，指针被置为nil就可以实现了。同时由此可知，如果大量使用附有</strong>weak修饰符的变量会消耗响应的CPU资源，因此，应该尽量少使用__weak修饰符。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/EffectiveObjective-C2.0第七章：系统框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/EffectiveObjective-C2.0第七章：系统框架/" itemprop="url">
                  EffectiveObjective-C2.0第七章：系统框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T22:07:29+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一条：多用块枚举，少用-for-循环"><a href="#第一条：多用块枚举，少用-for-循环" class="headerlink" title="第一条：多用块枚举，少用 for 循环"></a>第一条：多用块枚举，少用 for 循环</h3><p>遍历 collection 有四种方式。最基本的办法就是 for 循环，其次是 NSEnumerator 遍历法以及快速遍历法，最新、最先进的是“块枚举法”。</p>
<h4 id="传统的for遍历"><a href="#传统的for遍历" class="headerlink" title="传统的for遍历"></a>传统的for遍历</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">for (int i = 0; i &lt; anArray.count; i++) &#123;</div><div class="line">   id object = anArray[i];</div><div class="line">   // Do something with &apos;object&apos;</div><div class="line">&#125;</div><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">NSArray *keys = [aDictionary allKeys];</div><div class="line">for (int i = 0; i &lt; keys.count; i++) &#123;</div><div class="line">   id key = keys[i];</div><div class="line">   id value = aDictionary[key];</div><div class="line">   // Do something with &apos;key&apos; and &apos;value&apos;</div><div class="line">&#125;</div><div class="line">// Set</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">NSArray *objects = [aSet allObjects];</div><div class="line">for (int i = 0; i &lt; objects.count; i++) &#123;</div><div class="line">   id object = objects[i];</div><div class="line">   // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>我们可以看到，在遍历NSDictionary,和NSet时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。</p>
</blockquote>
<h4 id="利用快速遍历："><a href="#利用快速遍历：" class="headerlink" title="利用快速遍历："></a>利用快速遍历：</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">for (id object in anArray) &#123;</div><div class="line"> // Do something with &apos;object&apos;</div><div class="line">&#125;</div><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">for (id key in aDictionary) &#123;</div><div class="line"> id value = aDictionary[key];</div><div class="line"> // Do something with &apos;key&apos; and &apos;value&apos;</div><div class="line">&#125;</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">for (id object in aSet) &#123;</div><div class="line"> // Do something with &apos;object&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。</p>
</blockquote>
<h4 id="使用-Objective-C-1-0-的-NSEnumerator-来遍历"><a href="#使用-Objective-C-1-0-的-NSEnumerator-来遍历" class="headerlink" title="使用 Objective-C 1.0 的 NSEnumerator 来遍历"></a>使用 Objective-C 1.0 的 NSEnumerator 来遍历</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//正向遍历</div><div class="line"> NSArray *anArray = /* ... */;</div><div class="line">   NSEnumerator *enumerator = [anArray objectEnumerator];</div><div class="line">   id object;</div><div class="line">   while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">       // Do something with &apos;object&apos;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   //反向遍历</div><div class="line">   NSArray *anArray = /* ... */;</div><div class="line">   NSEnumerator *enumerator = [anArray reverseObjectEnumerator];</div><div class="line">   id object;	</div><div class="line">   while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">       // Do something with &apos;object&apos;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>

&gt; NSEnumerator 是个抽象基类，其中只定义了两个方法，供其具体子类来实现：  
`- (NSArray)allObjects`  
`- (id)nextObject`
</code></pre><h4 id="利用基于块（block）的遍历："><a href="#利用基于块（block）的遍历：" class="headerlink" title="利用基于块（block）的遍历："></a>利用基于块（block）的遍历：</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">NSArray *anArray = /* ... */;</div><div class="line">[anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)&#123;</div><div class="line">   // Do something with &apos;object&apos;</div><div class="line">   if (shouldStop) &#123;</div><div class="line">      *stop = YES; //使迭代停止</div><div class="line">  &#125;</div><div class="line">&#125;];</div><div class="line">// Dictionary</div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop)&#123;</div><div class="line">     // Do something with &apos;key&apos; and &apos;object&apos;</div><div class="line">     if (shouldStop) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">// Set</div><div class="line">NSSet *aSet = /* ... */;</div><div class="line">[aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop)&#123;</div><div class="line">     // Do something with &apos;object&apos;</div><div class="line">     if (shouldStop) &#123;</div><div class="line">        *stop = YES;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>我们可以看到，在使用块进行快速枚举的时候，我们可以不创建临时数组。虽然语法上没有快速枚举简洁，但是我们可以获得数组元素对应的序号，字典元素对应的键值，而且，我们还可以随时令遍历终止。<br>利用快速枚举和块的枚举还有一个优点：<strong>能够修改块的方法签名</strong></p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for (NSString *key in aDictionary) &#123;</div><div class="line">        NSString *object = (NSString*)aDictionary[key];</div><div class="line">       // Do something with &apos;key&apos; and &apos;object&apos;</div><div class="line">&#125;	</div><div class="line"></div><div class="line">NSDictionary *aDictionary = /* ... */;</div><div class="line">    [aDictionary enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSString *obj, BOOL *stop)&#123;</div><div class="line">             // Do something with &apos;key&apos; and &apos;obj&apos;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>如果我们可以知道集合里的元素类型，就可以修改签名。这样做的好处是：可以让编译期检查该元素是否可以实现我们想调用的方法，如果不能实现，就做另外的处理。这样一来，程序就能变得更加安全。</p>
</blockquote>
<h3 id="第二条：构建缓存时选用-NSCache-而非-NSDictionary"><a href="#第二条：构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="第二条：构建缓存时选用 NSCache 而非 NSDictionary"></a>第二条：构建缓存时选用 NSCache 而非 NSDictionary</h3><h4 id="NSCache-胜过-NSDictionary-之处在于："><a href="#NSCache-胜过-NSDictionary-之处在于：" class="headerlink" title="NSCache 胜过 NSDictionary 之处在于："></a>NSCache 胜过 NSDictionary 之处在于：</h4><ul>
<li>当系统资源将要耗尽时，NScache 可以自动删除缓存，并还会先删除“最久未用”的对象。</li>
<li>NSCache 并不会“拷贝”键，而是会“保留”它，原因在于：很多时候键，都是由不支持拷贝操作的对象来充当的。</li>
<li>NSCache 是线程安全的，开发者在不编写加锁代码的前提下，多个线程可以同时访问 NSCache 对象。</li>
</ul>
<h4 id="开发者可以操控缓存删减其内容的时机，有两个尺度可供调整："><a href="#开发者可以操控缓存删减其内容的时机，有两个尺度可供调整：" class="headerlink" title="开发者可以操控缓存删减其内容的时机，有两个尺度可供调整："></a>开发者可以操控缓存删减其内容的时机，有两个尺度可供调整：</h4><ul>
<li>缓存中的对象总数 （countLimit）</li>
<li>所有对象的总开销值（totalCostLimit）</li>
</ul>
<p>实例用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef void(^EXONetworkFetcherCompletionHandler)(NSData *data);</div><div class="line"></div><div class="line">@interface EXONetworkFetcher : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, strong, readonly) NSURL *url;</div><div class="line"></div><div class="line">- (instancetype)initWithURL:(NSURL*)url;</div><div class="line"></div><div class="line">- (void)startWithCompletionHandler:(EXONetworkFetcherCompletionHandler)handler;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass:NSobject ()</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass &#123;</div><div class="line">    NSCache *_cache;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _cache = [[NSCache alloc] init];</div><div class="line">        _cache.countLimit = 100;//对象总数</div><div class="line">        _cache.totalCostLimit = 5*1024*1024;//总开销5MB</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method</div><div class="line"></div><div class="line">- (void)p_downloadForURL:(NSURL*)url &#123;</div><div class="line">    NSData *cacheData = [_cache objectForKey:url];</div><div class="line">    if (cacheData) &#123;</div><div class="line">        [self p_userData:cacheData];</div><div class="line">    &#125;else &#123;</div><div class="line">        EXONetworkFetcher *fetcher = [[EXONetworkFetcher alloc] initWithURL:url];</div><div class="line">        [fetcher startWithCompletionHandler:^(NSData *data) &#123;</div><div class="line">            [_cache setObject:data forKey:url cost:data.length];</div><div class="line">            [self p_userData:data];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_userData:(NSData*)data &#123; &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="NSPurgeableData"><a href="#NSPurgeableData" class="headerlink" title="NSPurgeableData"></a>NSPurgeableData</h4><ul>
<li>NSPurgeableData 此类是 NSMutableData 的子类，而且实现了 NSDiscardableContent 协议。当系统资源紧张时，可以把保存 NSPurgeableData 的那块内存释放掉。</li>
<li>如果访问某个 NSPurgeableData 对象，可以调用其 beginContentAccess 方法，告诉它现在还不能丢弃自己所占据的内存，用完之后，调用 endContentAccess 方法，告诉它在必要的时候可以丢弃自己所占据的内存。</li>
<li>通过 NSCache 的 evictsObjectsWithDiscardedContent 属性，可以开启或关闭此功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@interface EOCClass:NSObject ()</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCClass &#123;</div><div class="line">    NSCache *_cache;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _cache = [[NSCache alloc] init];</div><div class="line">        _cache.countLimit = 100;//对象总数</div><div class="line">        _cache.totalCostLimit = 5*1024*1024;//总开销</div><div class="line">        _cache.evictsObjectsWithDiscardedContent = YES; //设置开启</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">#pragma mark - Method</div><div class="line"></div><div class="line">- (void)p_downloadForURL:(NSURL*)url &#123;</div><div class="line">    NSPurgeableData *cacheData = [_cache objectForKey:url];</div><div class="line">    if (cacheData) &#123;</div><div class="line">        [cacheData beginContentAccess];</div><div class="line">        [self p_userData:cacheData];</div><div class="line">        [cacheData endContentAccess];</div><div class="line">    &#125;else &#123;</div><div class="line">        EXONetworkFetcher *fetcher = [[EXONetworkFetcher alloc] initWithURL:url];</div><div class="line">        [fetcher startWithCompletionHandler:^(NSData *data) &#123;</div><div class="line">            NSPurgeableData *purgeaData = [NSPurgeableData dataWithData:data];</div><div class="line">            [_cache setObject:purgeaData forKey:url cost:purgeaData.length];</div><div class="line">            [self p_userData:data];</div><div class="line">            [purgeaData endContentAccess];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_userData:(NSData*)data &#123; &#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>注：在我们可以直接拿到purgeableData的情况下需要执行beginContentAccess方法。然而，在创建purgeableData的情况下，是不需要执行beginContentAccess，因为在创建了purgeableData之后，其引用计数会自动+1；</p>
</blockquote>
<h3 id="第三条：精简-initialize-与-load-的实现代码"><a href="#第三条：精简-initialize-与-load-的实现代码" class="headerlink" title="第三条：精简 initialize 与 load 的实现代码"></a>第三条：精简 initialize 与 load 的实现代码</h3><h4 id="load-方法"><a href="#load-方法" class="headerlink" title="load 方法"></a>load 方法</h4><p>+(void) load;<br>每个类和分类在加入运行期系统时，都会调用load方法，而且仅仅调用一次。</p>
<h4 id="initialize-方法"><a href="#initialize-方法" class="headerlink" title="initialize 方法"></a>initialize 方法</h4><p>+(void) initialize;<br>这个方法与load方法类似，区别是这个方法会在程序首次调用这个类的时候调用（惰性调用），而且只调用一次（绝对不能主动使用代码调用）。<br>值得注意的一点是，如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/Effective Objective-C 2.0 第六章：块与大中枢派发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/Effective Objective-C 2.0 第六章：块与大中枢派发/" itemprop="url">
                  EffectiveObjective-C2.0第六章：块与大中枢派发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T16:51:19+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一条：理解‘块’这一概念"><a href="#第一条：理解‘块’这一概念" class="headerlink" title="第一条：理解‘块’这一概念"></a>第一条：理解‘块’这一概念</h3><h4 id="块（block）分为三类："><a href="#块（block）分为三类：" class="headerlink" title="块（block）分为三类："></a>块（block）分为三类：</h4><ul>
<li><p>栈块：定义块的时候，其所占的内存区域是分配在栈中的，且只在定义它的那个范围内有效。下面定义的 block 只在 if else 范围内有效，若编译器未覆写待执行的块，则程序正常，否则，程序崩溃。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   void (^block)();</div><div class="line">   if ( /* some condition */ ) &#123;</div><div class="line">  		block = ^&#123;</div><div class="line">   			NSLog(@&quot;Block A&quot;);</div><div class="line">  		&#125;;</div><div class="line">&#125; else &#123;</div><div class="line">  		block = ^&#123;</div><div class="line">   			NSLog(@&quot;Block B&quot;);</div><div class="line">  		&#125;;</div><div class="line"> &#125;</div><div class="line"> block();</div></pre></td></tr></table></figure>
</li>
<li><p>堆块：为了解决上述问题我们可以复制一份到堆上，一旦复制到堆上，块就成了带引用计数的对象了，后续的复制操作不会真的执行复制。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void (^block)();</div><div class="line">    if ( /* some condition */ ) &#123;</div><div class="line">   		block = [^&#123;</div><div class="line">    			NSLog(@&quot;Block A&quot;);</div><div class="line">   		&#125; copy];</div><div class="line">	&#125; else &#123;</div><div class="line">   		block = [^&#123;</div><div class="line">    			NSLog(@&quot;Block B&quot;);</div><div class="line">   		&#125; copy];</div><div class="line">  &#125;</div><div class="line">  block();</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>全局块：这种块不会捕捉任何状态（变量等），运行时也无需有状态来参与，被声明在全局内存中，而不需要在每次用到的时候于栈中创建，相当于单例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void (^block)() = ^&#123;</div><div class="line">    		NSLog(@&quot;This is a block&quot;);</div><div class="line">﻿		&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第二条：使用-handler-块降低代码的分散程度"><a href="#第二条：使用-handler-块降低代码的分散程度" class="headerlink" title="第二条：使用 handler 块降低代码的分散程度"></a>第二条：使用 handler 块降低代码的分散程度</h3><ul>
<li>下载网络数据时，如果使用代理方法，会使得代码分布不紧凑，而且如果有多个下载任务的话，还要在回调的代理中判断当前请求的类型。但是如果使用block的话，就可以让网络下载的代码和回调处理的代码写在一起，这样就可以同时解决上面的两个问题：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@class EOCNetworkFetcher;</div><div class="line">typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);</div><div class="line">typedef void(^EOCNetworkFetcherErrorHandler)(NSError *error);</div><div class="line">@interface EOCNetworkFetcher : NSObject</div><div class="line">- (id)initWithURL:(NSURL*)url;</div><div class="line">- (void)startWithCompletionHandler: (EOCNetworkFetcherCompletionHandler)completion failureHandler: (EOCNetworkFetcherErrorHandler)failure;</div><div class="line">@end</div><div class="line">EOCNetworkFetcher *fetcher =[[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">[fetcher startWithCompletionHander:^(NSData *data)&#123;</div><div class="line">     // Handle success</div><div class="line">&#125;</div><div class="line"> failureHandler:^(NSError *error)&#123;</div><div class="line"> // Handle failure</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li>可以将处理成功的代码放在一个块里，处理失败的代码放在另一个块中,这样写的好处是，我们可以将处理成功和失败的代码分开来写，看上去更加清晰。</li>
</ul>
<h3 id="第三条：用块引用其所属对象时不要出现保留环"><a href="#第三条：用块引用其所属对象时不要出现保留环" class="headerlink" title="第三条：用块引用其所属对象时不要出现保留环"></a>第三条：用块引用其所属对象时不要出现保留环</h3><ul>
<li>如果块捕获的对象直接或间接地保留了块本身，那么就需要小心保留环问题:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@implementation EOCClass &#123;</div><div class="line">	     EOCNetworkFetcher *_networkFetcher;</div><div class="line">	     NSData *_fetchedData;</div><div class="line">	&#125;</div><div class="line">	- (void)downloadData &#123;</div><div class="line">	     NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/something.dat&quot;];</div><div class="line">	    _networkFetcher =[[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">	    [_networkFetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">	             NSLog(@&quot;Request URL %@ finished&quot;, _networkFetcher.url);</div><div class="line">	            _fetchedData = data;</div><div class="line">	    &#125;];</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在这里出现了保留环：块要设置_fetchedData变量，就需要捕获self变量。而self（EOCClass实例）通过实例变量保留了获取器_networkFetcher，而_networkFetcher又保留了块。<br>解决方案是：在快中去得到 data 后，将 _completionHandler 设置为 nil 打破保留环。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)startWithCompletionHandler:(EXONetworkFetcherCompletionHandler) completion &#123;</div><div class="line">	    self.completionHandler = completion;</div><div class="line">	    //start request</div><div class="line">	//    self.downloadData =</div><div class="line">	    if (_completionHandler) &#123;</div><div class="line">	        _completionHandler(_downloadData);</div><div class="line">	    &#125;</div><div class="line">	    _completionHandler = nil;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="第四条：多用派发队列，少用同步锁"><a href="#第四条：多用派发队列，少用同步锁" class="headerlink" title="第四条：多用派发队列，少用同步锁"></a>第四条：多用派发队列，少用同步锁</h3><ul>
<li><p>多线程执行同一份代码，可能会造成数据不同步，作者建议使用 GCD 来为代码加锁的方式来解决。</p>
</li>
<li><p>方案一：使用串行同步队列来将读写操作安排到同一个队列里</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_queue_create(&quot;com.effectiveobjectivec.syncQueue&quot;, NULL);</div><div class="line">//读取字符串</div><div class="line">- (NSString*)someString &#123;</div><div class="line">         __block NSString *localSomeString;</div><div class="line">         dispatch_sync(_syncQueue, ^&#123;</div><div class="line">            localSomeString = _someString;</div><div class="line">        &#125;);</div><div class="line">         return localSomeString;</div><div class="line">&#125;</div><div class="line">//设置字符串</div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">     dispatch_sync(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>这样一来，读写操作都在串行队列进行，就不容易出错。也可以将设置方法并发执行，但异步派发时需要拷贝块（block）若设置操作，比较耗时复杂，可考虑使用异步队列。</p>
</li>
<li><p>方案二： 将<strong>写操作</strong>放入栅栏块中，让他们单独执行，将<strong>读取操作</strong>并发执行</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">//读取字符串</div><div class="line">- (NSString*)someString &#123;</div><div class="line">     __block NSString *localSomeString;</div><div class="line">     dispatch_sync(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">     return localSomeString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//设置字符串</div><div class="line">- (void)setSomeString:(NSString*)someString &#123;</div><div class="line">     dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。<br>这里的dispatch_barrier_async方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。</li>
</ul>
<h3 id="第五条：多用GCD，-少用-performSelector-系列方法"><a href="#第五条：多用GCD，-少用-performSelector-系列方法" class="headerlink" title="第五条：多用GCD， 少用 performSelector 系列方法"></a>第五条：多用GCD， 少用 performSelector 系列方法</h3><ul>
<li><p>在iOS开发中，有时使用 performSelector 来执行某个方法，但是 performSelector 系列方法能处理的选择子很局限：</p>
</li>
<li><p>它无法处理带有多个参数的选择子</p>
</li>
<li><p>返回值只能是 void 或者对象类型</p>
</li>
<li><p>但是如果将方法放在块中，通过 GCD 来操作就能很好的解决，尤其是我们如果想让一个任务在另一个线程上执行，最好应该将任务放到块里，交给 GCD 来实现，而不是通过 performSelector 方法。</p>
</li>
</ul>
<ol>
<li><p>延后执行某个任务的方法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 使用 performSelector:withObject:afterDelay:</div><div class="line">[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];</div><div class="line">// 使用 dispatch_after</div><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123;</div><div class="line">    [self doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>将任务放在主线程执行：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">	// 使用 performSelectorOnMainThread:withObject:waitUntilDone:</div><div class="line">[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];</div><div class="line">// 使用 dispatch_async</div><div class="line">// (or if waitUntilDone is YES, then dispatch_sync)</div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [self doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第六条：掌握-GCD-及操作队列的使用时机"><a href="#第六条：掌握-GCD-及操作队列的使用时机" class="headerlink" title="第六条：掌握 GCD 及操作队列的使用时机"></a>第六条：掌握 GCD 及操作队列的使用时机</h3><ul>
<li><p>除了GCD，操作队列（NSOperationQueue）也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用GCD好些，有时则是使用操作队列更加合理。</p>
</li>
<li><p>使用NSOperation和NSOperationQueue的优点：</p>
</li>
</ul>
<ol>
<li>可以取消操作：<strong>在运行任务前</strong>，可以在NSOperation对象调用cancel方法，标明此任务不需要执行。但是GCD队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。</li>
<li>可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。</li>
<li>监控NSOperation对象的属性：可以通过KVO来监听NSOperation的属性：可以通过isCancelled属性来判断任务是否已取消；通过isFinished属性来判断任务是否已经完成。</li>
<li>可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。</li>
<li>可以重用 NSOperation 对象，系统内置了一些 NSOperation 的子类（NSBlockOperation）供开发者使用，也可以自己创建子类，能够存放任何信息，这比派发队列中那些简单的块要强大许多。</li>
</ol>
<h3 id="第七条：通过-Dispatch-Group-机制，根据系统资源状况来执行任务"><a href="#第七条：通过-Dispatch-Group-机制，根据系统资源状况来执行任务" class="headerlink" title="第七条：通过 Dispatch Group 机制，根据系统资源状况来执行任务"></a>第七条：通过 Dispatch Group 机制，根据系统资源状况来执行任务</h3><ul>
<li>有时需要等待多个并行任务结束的那一刻执行某个任务，这个时候就可以使用dispath group函数来实现这个需求：</li>
<li>通过dispath group函数，可以把并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//一个优先级低的并发队列</div><div class="line">dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</div><div class="line">//一个优先级高的并发队列</div><div class="line">dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</div><div class="line">//创建dispatch_group</div><div class="line">dispatch_group_t dispatchGroup = dispatch_group_create();</div><div class="line">//将优先级低的队列放入dispatch_group</div><div class="line">for (id object in lowPriorityObjects)&#123;     dispatch_group_async(dispatchGroup,lowPriorityQueue,^&#123; [object performTask]; &#125;);</div><div class="line">   &#125;</div><div class="line">//将优先级高的队列放入dispatch_group</div><div class="line">for (id object in highPriorityObjects) &#123;</div><div class="line">    dispatch_group_async(dispatchGroup,highPriorityQueue,^&#123; [object performTask]; &#125;); &#125;</div><div class="line">//dispatch_group里的任务都结束后调用块中的代码</div><div class="line">dispatch_queue_t notifyQueue = dispatch_get_main_queue();</div><div class="line">dispatch_group_notify(dispatchGroup,notifyQueue,^&#123;</div><div class="line">    // Continue processing after completing tasks</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>开发者未必总需要使用 dispatch group。有时候采用串行队列搭配标准的异步派发也可以实现相同的效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(&quot;com,effrctiveobjectives.queue&quot;, Null);</div><div class="line">for (id object in collection) &#123;</div><div class="line"> dispatch_async(queue,^&#123; [object performTask]; &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">dispatch_async(queue,^&#123;</div><div class="line">	//执行完上面的block后，执行此方法。</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="第八条：使用-dispatch-once-来执行只需运行一次的线程安全代码"><a href="#第八条：使用-dispatch-once-来执行只需运行一次的线程安全代码" class="headerlink" title="第八条：使用 dispatch_once 来执行只需运行一次的线程安全代码"></a>第八条：使用 dispatch_once 来执行只需运行一次的线程安全代码</h3><ul>
<li>有时我们可能只需要将某段代码执行一次，这时可以通过dispatch_once函数来解决。<br>dispatch_once函数比较重要的使用例子是单例模式：<br>我们在创建单例模式的实例时，可以使用dispatch_once函数来令初始化代码只执行一次，并且内部是线程安全的。<br>而且，对于执行一次的block来说，每次调用函数时传入的标记都必须完全相同，通常标记变量声明在static或global作用域里。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (id)sharedInstance &#123;</div><div class="line">     static EOCClass *sharedInstance = nil;</div><div class="line">     static dispatch_once_t onceToken;</div><div class="line">     dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">﻿            sharedInstance = [[self alloc] init];</div><div class="line">    &#125;);</div><div class="line">     return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们可以这么理解：在dispatch_once块中的代码在程序启动到终止的过程里，只要运行了一次后，就给自己加上了注释符号，不再存在了。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/Effective Objective-C 2.0 第五章：内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/Effective Objective-C 2.0 第五章：内存管理/" itemprop="url">
                  Effective Objective-C 2.0 第五章：内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T09:34:48+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一条：在-dealloc-方法中释放引用并解除监听"><a href="#第一条：在-dealloc-方法中释放引用并解除监听" class="headerlink" title="第一条：在 dealloc 方法中释放引用并解除监听"></a>第一条：在 dealloc 方法中释放引用并解除监听</h3><ul>
<li>应该在 dealloc 中释放对象所拥有的引用，ARC 会自动为所有的 Objective-C 对象添加释放代码，其他非 Objective-C 对象需手动释放（CoreFoundation）。</li>
<li>把原来配置过的观测行为（KVC）或 NSNotificationCenter，一般应该在这里注销。</li>
<li>在 dealloc 中不要调用属性的存取方法，可能有人覆写过这些方法，并于其中做一些无法再回收阶段安全执行的操作，属性可能处于“键值观察”（KVC）机制的监控之下。</li>
<li>执行异步任务的方法不应该在 dealloc 里调用，正常执行的方法也不应该在调用，因为对象正处于回收的状态了。</li>
<li>如果对象持有文件描述符等系统资源，应专门写一个方法来释放资源，并于其他使用者约定，用完资源后必须调用 close 方法。</li>
</ul>
<h3 id="第二条：自动释放-autoreleasepool"><a href="#第二条：自动释放-autoreleasepool" class="headerlink" title="第二条：自动释放 @autoreleasepool"></a>第二条：自动释放 @autoreleasepool</h3><ul>
<li>使用弱引用避免保留环（weak）</li>
<li>是么时候使用 @autoreleasepool<ol>
<li>写基于命令行的程序时，就是没有UI框架，如 AppKit 等 Cocoa 框架时。</li>
<li>写循环，循环中包含大量临时创建的对象。</li>
<li>创建了新的线程。（非 Cocoa 程序创建线程时才需要）</li>
<li>长时间在后台运行的任务。</li>
</ol>
</li>
<li><p>利用 @autoreleasepool 优化内存占用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	//来自Apple文档，见参考</div><div class="line">NSArray *urls = &lt;# An array of file URLs #&gt;;</div><div class="line">for (NSURL *url in urls) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSError *error;</div><div class="line">        NSString *fileContents = [NSString stringWithContentsOfURL:url</div><div class="line">                                        encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">        /* Process the string, creating and autoreleasing more objects. */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第三条：用“僵尸对象”调试内存管理问题"><a href="#第三条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第三条：用“僵尸对象”调试内存管理问题"></a>第三条：用“僵尸对象”调试内存管理问题</h3><ul>
<li>开启方式：编辑应用程序的 Scheme，在对话框左侧选择 ”Run“，然后切换至 “Diagnostics”分页，最后勾选 “Enable Zombie（[‘zɑmbi]    行尸走肉；蛇神；木讷呆板的人）     Objects” 选项。</li>
<li>开启后，系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象（系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象的僵尸对象可以相应所有的选择子）。</li>
<li>响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。</li>
</ul>
<h3 id="第四条：iOS-定时器-NSTimer-中的循环引用"><a href="#第四条：iOS-定时器-NSTimer-中的循环引用" class="headerlink" title="第四条：iOS 定时器 NSTimer 中的循环引用"></a>第四条：iOS 定时器 NSTimer 中的循环引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</div><div class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</div></pre></td></tr></table></figure>
<ul>
<li>由于循环引用的起因是target，则可以包装一个 target，让 target 指向另一个对象，而不是当前调用的对象，即可解决循环引用。</li>
<li>在使用 NSTimer 时，可以使用不带有 target 的类方法（block）。</li>
<li><code>timerWithTimeInterval</code>需要加入<code>RunLoop</code> <code>scheduledTimerWithTimeInterval</code> 不用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">方法一</div><div class="line">#import &quot;EXOTimerBlock.h&quot;</div><div class="line"></div><div class="line">@interface EXOTimerBlock()</div><div class="line"></div><div class="line">@property (nonatomic, assign)SEL selector;</div><div class="line">@property (nonatomic, strong)  NSTimer *timer;</div><div class="line">@property (nonatomic, weak)  id target;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EXOTimerBlock</div><div class="line"></div><div class="line">+ (NSTimer* _Nonnull)EXOTimerWithTimeInterval:(NSTimeInterval)ti</div><div class="line">                                       target:(id _Nonnull)aTarget</div><div class="line">                                     selector:(SEL _Nonnull)aSelector</div><div class="line">                                     userInfo:(nullable id)userInfo</div><div class="line">                                      repeats:(BOOL)yesOrNo&#123;</div><div class="line">    </div><div class="line">    EXOTimerBlock *timerBlock = [[EXOTimerBlock alloc] init];</div><div class="line">    timerBlock.selector = aSelector;</div><div class="line">    timerBlock.target = aTarget;</div><div class="line">    timerBlock.timer = [NSTimer timerWithTimeInterval:ti target:timerBlock selector:@selector(EXOFire:) userInfo:userInfo repeats:yesOrNo];</div><div class="line">    return timerBlock.timer;</div><div class="line">&#125;</div><div class="line">- (void)EXOFire:(NSTimer*)timer &#123;</div><div class="line">    if (self.target) &#123;</div><div class="line">        [self.target performSelector:self.selector withObject:timer.userInfo];</div><div class="line">    &#125;else &#123;</div><div class="line">        [timer invalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方法二</div><div class="line"></div><div class="line">#import &quot;NSTimer+EXOBlock.h&quot;</div><div class="line">@implementation NSTimer (EXOBlock)</div><div class="line"></div><div class="line">+ (NSTimer*)EXOTimerWithTimeInterval:(NSTimeInterval)ti block:(nullable void(^)()) block userInfo:(id)userInfo repeats:(BOOL)yesOrNo &#123;</div><div class="line">    return [self timerWithTimeInterval:ti target:self selector:@selector(p_exoTimerSelector:) userInfo:[block copy] repeats:yesOrNo];</div><div class="line">&#125;</div><div class="line">+ (void)p_exoTimerSelector:(NSTimer*)timer&#123;</div><div class="line">    void (^block)() = [timer userInfo];</div><div class="line">    if (block) &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="第五条：performselector-的内存泄漏问题"><a href="#第五条：performselector-的内存泄漏问题" class="headerlink" title="第五条：performselector 的内存泄漏问题"></a>第五条：performselector 的内存泄漏问题</h3><ul>
<li>performSelector关于内存管理的执行原理是这样的：执行 [self performSelector:@selector(method1:) withObject:self afterDelay:3]; 的时候，系统会将self的引用计数加1，执行完这个方法时，还会将self的引用计数减1，<strong>当方法还没有执行的时候，要返回父视图释放当前视图的时候，self的计数没有减少到0，而导致无法调用dealloc方法，出现了内存泄露</strong>。</li>
<li>解决办法就是取消那些还没有来得及执行的延时函数，代码很简单：<br><code>[NSObject cancelPreviousPerformRequestsWithTarget:self]</code><br>当然你也可以一个一个得这样用：<br><code>[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(method1:) object:nil]</code><br>加上了这个以后，dealloc方法就会被调用，问题解决！ </li>
</ul>
<p> </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/08/Effective Objective-C 2.0 第四章：协议与分类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhenyue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gbetter">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/Effective Objective-C 2.0 第四章：协议与分类/" itemprop="url">
                  Effective Objective-C 2.0 第四章：协议与分类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T11:24:11+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一条：将类的实现代码分散到便于管理的数个分类之中"><a href="#第一条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第一条：将类的实现代码分散到便于管理的数个分类之中"></a>第一条：将类的实现代码分散到便于管理的数个分类之中</h3><ul>
<li>可以通过 Objective-C 的 “分类” 机制，把类代码按逻辑划入几个分区中，便于开发和调试。</li>
<li>使用分类机制后若分类数量过多，可将每个分类提取到各自的文件中。</li>
<li>将应该视为“私有”的方法归入名叫 Private 的分类中，以隐藏实现细节</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EXOStudent : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@interface EXOStudent (Friendship)</div><div class="line">- (void)addFriend:(EXOStudent*)student;</div><div class="line">- (void)removeFriend:(EXOStudent*)stuendt;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface EXOStudent (Work)</div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line">@end  </div><div class="line"></div><div class="line">#import &quot;EXOStudent.h&quot;</div><div class="line"></div><div class="line">@implementation EXOStudent</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EXOStudent (Friendship)</div><div class="line">- (void)addFriend:(EXOStudent*)student &#123;//do&#125;</div><div class="line">- (void)removeFriend:(EXOStudent*)stuendt &#123;//do&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EXOStudent (Work)</div><div class="line">- (void)performDaysWork &#123;//do&#125;</div><div class="line">- (void)takeVacationFromWork &#123;//do&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="第二条：勿在分类中声明属性"><a href="#第二条：勿在分类中声明属性" class="headerlink" title="第二条：勿在分类中声明属性"></a>第二条：勿在分类中声明属性</h3><ul>
<li>把封装数据所用的全部属性都定义在主接口里。</li>
<li><p>在 <code>class-continuation</code> 分类 之外的其他分类中，可以定义存取方法，但尽量不要。(<strong>通过设置关联对象的方式给其他分类设置存取方法</strong>⏬)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	- (void)setStudentName:(NSString *)studentName &#123;</div><div class="line">    objc_setAssociatedObject(self, kIndieStudentNameKey, studentName, OBJC_ASSOCIATION_COPY);</div><div class="line">&#125;</div><div class="line">	- (NSString*)studentName &#123;</div><div class="line">    return objc_getAssociatedObject(self, kIndieStudentNameKey);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第三条：使用-“class-continuation”-隐藏实现细节"><a href="#第三条：使用-“class-continuation”-隐藏实现细节" class="headerlink" title="第三条：使用 “class-continuation” 隐藏实现细节"></a>第三条：使用 “class-continuation” 隐藏实现细节</h3><ul>
<li>通过 “class-continuation 分类”向类中新增实例变量。</li>
<li>如果某些属性在主接口中声明为“只读”，而在类的内部又要用设置方法修改此属性，那么就在“class-continuation 分类” 中将其扩展为 “可读写”。</li>
<li>把私有方法的原型声明在 “class-continuation 分类” 里面。</li>
<li>若想使类所遵循的协议不为人所知，则可于 “class-continuation 分类”中声明。</li>
</ul>
<h3 id="第四条：通过协议提供匿名对象"><a href="#第四条：通过协议提供匿名对象" class="headerlink" title="第四条：通过协议提供匿名对象"></a>第四条：通过协议提供匿名对象</h3><ul>
<li>我们可以用协议把自己所写的API中的实现细节隐藏起来，将返回的对象设计为遵从此协议的 id 类型。<br><code>@property (nonatomic, weak)id&lt;ECODelegate&gt; delegate;</code><br><code>- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey</code></li>
<li>如果具体类型不重要，重要的是对象能响应（协议）方法，可以用匿名对象来表示。</li>
<li>如果几个界面是相似的，那么就可以利用协议返回统一的数据来处理。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zhenyue" />
          <p class="site-author-name" itemprop="name">zhenyue</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhenyue</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
